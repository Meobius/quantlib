/*
 * FILE : quantlib_wrap.cpp
 * 
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Patch 5)
 * 
 * Portions Copyright (c) 1995-1998
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */


#define SWIGCODE
/* Implementation : PYTHON */

#define SWIGPYTHON
#include <string.h>
#include <stdlib.h>
/***********************************************************************
 * $Header$
 * swig_lib/python/python.cfg
 *
 * This file contains coded needed to add variable linking to the
 * Python interpreter.   C variables are added as a new kind of Python
 * datatype.
 *
 * Also contains supporting code for building python under Windows
 * and things like that.
 *
 * $Log$
 * Revision 1.49  2001/01/17 18:20:31  enri
 * the python target is now generatet only iff you have swig installed. (configure.in)
 * added/removed some missing/extra files in Makefile.am's
 *
 ************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif
#include "Python.h"
#ifdef __cplusplus
}
#endif

/* Definitions for Windows/Unix exporting */
#if defined(__WIN32__)
#   if defined(_MSC_VER)
#	define SWIGEXPORT(a,b) __declspec(dllexport) a b
#   else
#	if defined(__BORLANDC__)
#	    define SWIGEXPORT(a,b) a _export b
#	else
#	    define SWIGEXPORT(a,b) a b
#	endif
#   endif
#else
#   define SWIGEXPORT(a,b) a b
#endif

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif

typedef struct {
  char  *name;
  PyObject *(*get_attr)(void);
  int (*set_attr)(PyObject *);
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar **vars;
  int      nvars;
  int      maxvars;
} swig_varlinkobject;

/* ----------------------------------------------------------------------
   swig_varlink_repr()

   Function for python repr method
   ---------------------------------------------------------------------- */

static PyObject *
swig_varlink_repr(swig_varlinkobject *v)
{
  v = v;
  return PyString_FromString("<Global variables>");
}

/* ---------------------------------------------------------------------
   swig_varlink_print()

   Print out all of the global variable names
   --------------------------------------------------------------------- */

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags)
{

  int i = 0;
  flags = flags;
  fprintf(fp,"Global variables { ");
  while (v->vars[i]) {
    fprintf(fp,"%s", v->vars[i]->name);
    i++;
    if (v->vars[i]) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

/* --------------------------------------------------------------------
   swig_varlink_getattr
 
   This function gets the value of a variable and returns it as a
   PyObject.   In our case, we'll be looking at the datatype and
   converting into a number or string
   -------------------------------------------------------------------- */

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n)
{
  int i = 0;
  char temp[128];

  while (v->vars[i]) {
    if (strcmp(v->vars[i]->name,n) == 0) {
      return (*v->vars[i]->get_attr)();
    }
    i++;
  }
  sprintf(temp,"C global variable %s not found.", n);
  PyErr_SetString(PyExc_NameError,temp);
  return NULL;
}

/* -------------------------------------------------------------------
   swig_varlink_setattr()

   This function sets the value of a variable.
   ------------------------------------------------------------------- */

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p)
{
  char temp[128];
  int i = 0;
  while (v->vars[i]) {
    if (strcmp(v->vars[i]->name,n) == 0) {
      return (*v->vars[i]->set_attr)(p);
    }
    i++;
  }
  sprintf(temp,"C global variable %s not found.", n);
  PyErr_SetString(PyExc_NameError,temp);
  return 1;
}

statichere PyTypeObject varlinktype = {
/*  PyObject_HEAD_INIT(&PyType_Type)  Note : This doesn't work on some machines */
  PyObject_HEAD_INIT(0)              
  0,
  "varlink",                          /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */

SWIGSTATIC PyObject *
SWIG_newvarlink(void)
{
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  /*  _Py_NewReference(result);  Does not seem to be necessary */
  result->nvars = 0;
  result->maxvars = 64;
  result->vars = (swig_globalvar **) malloc(64*sizeof(swig_globalvar *));
  result->vars[0] = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGSTATIC void
SWIG_addvarlink(PyObject *p, char *name,
	   PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p))
{
  swig_varlinkobject *v;
  v= (swig_varlinkobject *) p;
	
  if (v->nvars >= v->maxvars -1) {
    v->maxvars = 2*v->maxvars;
    v->vars = (swig_globalvar **) realloc(v->vars,v->maxvars*sizeof(swig_globalvar *));
    if (v->vars == NULL) {
      fprintf(stderr,"SWIG : Fatal error in initializing Python module.\n");
      exit(1);
    }
  }
  v->vars[v->nvars] = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  v->vars[v->nvars]->name = (char *) malloc(strlen(name)+1);
  strcpy(v->vars[v->nvars]->name,name);
  v->vars[v->nvars]->get_attr = get_attr;
  v->vars[v->nvars]->set_attr = set_attr;
  v->nvars++;
  v->vars[v->nvars] = 0;
}



/*****************************************************************************
 * $Header$
 *
 * swigptr.swg
 *
 * This file contains supporting code for the SWIG run-time type checking
 * mechanism.  The following functions are available :
 *
 * SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *));
 *
 *      Registers a new type-mapping with the type-checker.  origtype is the
 *      original datatype and newtype is an equivalent type.  cast is optional
 *      pointer to a function to cast pointer values between types (this
 *      is typically used to cast pointers from derived classes to base classes in C++)
 *      
 * SWIG_MakePtr(char *buffer, void *ptr, char *typestring);
 *     
 *      Makes a pointer string from a pointer and typestring.  The result is returned
 *      in buffer which is assumed to hold enough space for the result.
 *
 * char * SWIG_GetPtr(char *buffer, void **ptr, char *type)
 *
 *      Gets a pointer value from a string.  If there is a type-mismatch, returns
 *      a character string to the received type.  On success, returns NULL.
 *
 *
 * You can remap these functions by making a file called "swigptr.swg" in
 * your the same directory as the interface file you are wrapping.
 *
 * These functions are normally declared static, but this file can be
 * can be used in a multi-module environment by redefining the symbol
 * SWIGSTATIC.
 *****************************************************************************/

#include <stdlib.h>

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif


/* SWIG pointer structure */

typedef struct SwigPtrType {
  char               *name;               /* Datatype name                  */
  int                 len;                /* Length (used for optimization) */
  void               *(*cast)(void *);    /* Pointer casting function       */
  struct SwigPtrType *next;               /* Linked list pointer            */
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

/* Some variables  */

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
                                       /* This value may be adjusted dynamically */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static int SwigStart[256];             /* Starting positions of types            */

/* Pointer table */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

SWIGSTATIC 
void SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {

  int i;
  SwigPtrType *t = 0,*t1;

  /* Allocate the pointer table if necessary */

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  /* Grow the table */
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc((char *) SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }

  /* Check for existing entry */

  while (t->next) {
    if ((strcmp(t->name,newtype) == 0)) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  
  /* Now place entry (in sorted order) */

  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;            
  t->next = t1;           
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATIC 
void SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Define for backwards compatibility */

#define _swig_make_hex   SWIG_MakePtr 

/* Function for getting a pointer value */

SWIGSTATIC 
char *SWIG_GetPtr(char *_c, void **ptr, char *_t)
{
  unsigned long _p;
  char temp_type[256];
  char *name;
  int  i, len;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;
  int  start, end;
  _p = 0;

  /* Pointer values must start with leading underscore */
  if (*_c == '_') {
      _c++;
      /* Extract hex value from pointer */
      while (*_c) {
	  if ((*_c >= '0') && (*_c <= '9'))
	    _p = (_p << 4) + (*_c - '0');
	  else if ((*_c >= 'a') && (*_c <= 'f'))
	    _p = (_p << 4) + ((*_c - 'a') + 10);
	  else
	    break;
	  _c++;
      }

      if (_t) {
	if (strcmp(_t,_c)) { 
	  if (!SwigPtrSort) {
	    qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort); 
	    for (i = 0; i < 256; i++) {
	      SwigStart[i] = SwigPtrN;
	    }
	    for (i = SwigPtrN-1; i >= 0; i--) {
	      SwigStart[(int) (SwigPtrTable[i].name[1])] = i;
	    }
	    for (i = 255; i >= 1; i--) {
	      if (SwigStart[i-1] > SwigStart[i])
		SwigStart[i-1] = SwigStart[i];
	    }
	    SwigPtrSort = 1;
	    for (i = 0; i < SWIG_CACHESIZE; i++)  
	      SwigCache[i].stat = 0;
	  }
	  
	  /* First check cache for matches.  Uses last cache value as starting point */
	  cache = &SwigCache[SwigLastCache];
	  for (i = 0; i < SWIG_CACHESIZE; i++) {
	    if (cache->stat) {
	      if (strcmp(_t,cache->name) == 0) {
		if (strcmp(_c,cache->mapped) == 0) {
		  cache->stat++;
		  *ptr = (void *) _p;
		  if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
		  return (char *) 0;
		}
	      }
	    }
	    SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	    if (!SwigLastCache) cache = SwigCache;
	    else cache++;
	  }
	  /* We have a type mismatch.  Will have to look through our type
	     mapping table to figure out whether or not we can accept this datatype */

	  start = SwigStart[(int) _t[1]];
	  end = SwigStart[(int) _t[1]+1];
	  sp = &SwigPtrTable[start];
	  while (start < end) {
	    if (swigcmp(_t,sp) == 0) break;
	    sp++;
	    start++;
	  }
	  if (start >= end) sp = 0;
	  /* Try to find a match for this */
	  if (sp) {
	    while (swigcmp(_t,sp) == 0) {
	      name = sp->name;
	      len = sp->len;
	      tp = sp->next;
	      /* Try to find entry for our given datatype */
	      while(tp) {
		if (tp->len >= 255) {
		  return _c;
		}
		strcpy(temp_type,tp->name);
		strncat(temp_type,_t+len,255-tp->len);
		if (strcmp(_c,temp_type) == 0) {
		  
		  strcpy(SwigCache[SwigCacheIndex].mapped,_c);
		  strcpy(SwigCache[SwigCacheIndex].name,_t);
		  SwigCache[SwigCacheIndex].stat = 1;
		  SwigCache[SwigCacheIndex].tp = tp;
		  SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
		  
		  /* Get pointer value */
		  *ptr = (void *) _p;
		  if (tp->cast) *ptr = (*(tp->cast))(*ptr);
		  return (char *) 0;
		}
		tp = tp->next;
	      }
	      sp++;
	      /* Hmmm. Didn't find it this time */
	    }
	  }
	  /* Didn't find any sort of match for this data.  
	     Get the pointer value and return the received type */
	  *ptr = (void *) _p;
	  return _c;
	} else {
	  /* Found a match on the first try.  Return pointer value */
	  *ptr = (void *) _p;
	  return (char *) 0;
	}
      } else {
	/* No type specified.  Good luck */
	*ptr = (void *) _p;
	return (char *) 0;
      }
  } else {
    if (strcmp (_c, "NULL") == 0) {
	*ptr = (void *) 0;
	return (char *) 0;
    }
    *ptr = (void *) 0;	
    return _c;
  }
}

/* Compatibility mode */

#define _swig_get_hex  SWIG_GetPtr

#define SWIG_init    initQuantLibc

#define SWIG_name    "QuantLibc"

#include "quantlib.h"

#include "quantlib.h"

using QuantLib::FiniteDifferences::BoundaryCondition;
typedef BoundaryCondition::Type BoundaryConditionType;
using QuantLib::StringFormatter;

#include "quantlib.h"

#include "quantlib.h"

#include "quantlib.h"

	typedef std::string String;

	typedef std::vector<std::string> StringVector;

#include <cstdlib>
#include <string>
using QuantLib::Date;

using QuantLib::Day;
using QuantLib::Year;
using QuantLib::Time;

using QuantLib::Weekday;
using QuantLib::Sunday;
using QuantLib::Monday;
using QuantLib::Tuesday;
using QuantLib::Wednesday;
using QuantLib::Thursday;
using QuantLib::Friday;
using QuantLib::Saturday;

using QuantLib::StringFormatter;
using QuantLib::DateFormatter;

using QuantLib::Month;
using QuantLib::January;
using QuantLib::February;
using QuantLib::March;
using QuantLib::April;
using QuantLib::May;
using QuantLib::June;
using QuantLib::July;
using QuantLib::August;
using QuantLib::September;
using QuantLib::October;
using QuantLib::November;
using QuantLib::December;

using QuantLib::TimeUnit;
using QuantLib::Days;
using QuantLib::Weeks;
using QuantLib::Months;
using QuantLib::Years;

typedef std::vector<Date> DateVector;

	Date DateFromSerialNumber(int serialNumber) {
		return Date(serialNumber);
	}

using QuantLib::Handle;
using QuantLib::Calendar;
typedef Handle<Calendar> CalendarHandle;

using QuantLib::IsNull;

using QuantLib::Calendars::TARGET;
using QuantLib::Calendars::NewYork;
using QuantLib::Calendars::London;
using QuantLib::Calendars::Milan;
using QuantLib::Calendars::Frankfurt;
using QuantLib::Calendars::Zurich;

CalendarHandle NewTARGET()    { return CalendarHandle(new TARGET); }
CalendarHandle NewNewYork()   { return CalendarHandle(new NewYork); }
CalendarHandle NewLondon()    { return CalendarHandle(new London); }
CalendarHandle NewFrankfurt() { return CalendarHandle(new Frankfurt); }
CalendarHandle NewMilan()     { return CalendarHandle(new Milan); }
CalendarHandle NewZurich()    { return CalendarHandle(new Zurich); }

#include "quantlib.h"

using QuantLib::Currency;
using QuantLib::Handle;
typedef Handle<Currency> CurrencyHandle;

using QuantLib::Currencies::EUR;
using QuantLib::Currencies::USD;
using QuantLib::Currencies::GBP;
using QuantLib::Currencies::DEM;
using QuantLib::Currencies::ITL;
using QuantLib::Currencies::AUD;
using QuantLib::Currencies::CAD;
using QuantLib::Currencies::CHF;
using QuantLib::Currencies::DKK;
using QuantLib::Currencies::JPY;
using QuantLib::Currencies::SEK;

CurrencyHandle NewEUR()		{ return CurrencyHandle(new EUR); }
CurrencyHandle NewUSD()		{ return CurrencyHandle(new USD); }
CurrencyHandle NewGBP()		{ return CurrencyHandle(new GBP); }
CurrencyHandle NewDEM()		{ return CurrencyHandle(new DEM); }
CurrencyHandle NewITL()		{ return CurrencyHandle(new ITL); }
CurrencyHandle NewAUD()		{ return CurrencyHandle(new AUD); }
CurrencyHandle NewCAD()		{ return CurrencyHandle(new CAD); }
CurrencyHandle NewCHF()		{ return CurrencyHandle(new CHF); }
CurrencyHandle NewDKK()		{ return CurrencyHandle(new DKK); }
CurrencyHandle NewJPY()		{ return CurrencyHandle(new JPY); }
CurrencyHandle NewSEK()		{ return CurrencyHandle(new SEK); }

typedef std::vector<Handle<Currency> > CurrencyHandleVector;

#include "quantlib.h"

using QuantLib::DayCounter;
using QuantLib::Handle;
typedef Handle<DayCounter> DayCounterHandle;

using QuantLib::DayCounters::Actual360;
using QuantLib::DayCounters::Actual365;
using QuantLib::DayCounters::Thirty360;
using QuantLib::DayCounters::Thirty360European;
using QuantLib::DayCounters::Thirty360Italian;

DayCounterHandle NewActual360() {
    return DayCounterHandle(new Actual360); }
DayCounterHandle NewActual365() { 
    return DayCounterHandle(new Actual365); }
DayCounterHandle NewThirty360() {
    return DayCounterHandle(new Thirty360); }
DayCounterHandle NewThirty360European() {
    return DayCounterHandle(new Thirty360European); }
DayCounterHandle NewThirty360Italian() {
    return DayCounterHandle(new Thirty360Italian); }

#include "quantlib.h"

using QuantLib::Math::NormalDistribution;
using QuantLib::Math::CumulativeNormalDistribution;
using QuantLib::Math::InvCumulativeNormalDistribution;

#include "quantlib.h"

using QuantLib::Rate;
using QuantLib::Spread;
using QuantLib::DiscountFactor;

#include "quantlib.h"

#include "quantlib.h"

#include <vector>
typedef std::vector<int> IntVector;
typedef std::vector<double> DoubleVector;
using QuantLib::Array;
typedef QuantLib::Array PyArray;
typedef QuantLib::Math::LexicographicalView<Array::iterator> ArrayLexicographicalView;
typedef QuantLib::Math::LexicographicalView<Array::iterator>::y_iterator 
	ArrayLexicographicalViewColumn;
using QuantLib::Null;

    ArrayLexicographicalView CreateLexicographicView(Array& a, int xSize) {
        return ArrayLexicographicalView(a.begin(),a.end(),xSize);
    }

#include "history.h"

using QuantLib::History;
typedef QuantLib::History::const_iterator HistoryIterator;
typedef QuantLib::History::const_valid_iterator HistoryValidIterator;
typedef QuantLib::History::const_data_iterator HistoryDataIterator;
typedef QuantLib::History::const_valid_data_iterator HistoryValidDataIterator;
using QuantLib::DateFormatter;
using QuantLib::DoubleFormatter;

#include "quantlib.h"

#include "quantlib.h"

using QuantLib::TermStructure;
using QuantLib::Handle;
typedef Handle<TermStructure> TermStructureHandle;

using QuantLib::ImpliedTermStructure;

TermStructureHandle NewImpliedTermStructure(TermStructureHandle curve, 
  Date evaluationDate) {
	return Handle<TermStructure>(
	  new ImpliedTermStructure(curve,evaluationDate));
}

using QuantLib::SpreadedTermStructure;

TermStructureHandle NewSpreadedTermStructure(TermStructureHandle curve, 
  Spread spread) {
	return Handle<TermStructure>(new SpreadedTermStructure(curve,spread));
}

using QuantLib::TermStructures::FlatForward;

TermStructureHandle NewFlatForward(CurrencyHandle currency, 
  DayCounterHandle dayCounter, Date today, Rate forward) {
	return Handle<TermStructure>(
	  new FlatForward(currency,dayCounter,today,forward));
}

using QuantLib::TermStructures::PiecewiseConstantForwards;
using QuantLib::Deposit;

typedef std::vector<Deposit> DepositList;

TermStructureHandle NewPiecewiseConstantForwards(CurrencyHandle currency, 
  DayCounterHandle dayCounter, Date today, DepositList deposits) {
	return Handle<TermStructure>(
	  new PiecewiseConstantForwards(currency,dayCounter,today,deposits));
}

#include <cstdlib>
using QuantLib::Instrument;
using QuantLib::Handle;
typedef Handle<Instrument> InstrumentHandle;

std::string Representation(const Handle<Instrument>& i) {
	std::string isin = i->isinCode();
	if (isin == "")
		isin = "unknown";
	std::string desc = i->description();
	if (desc == "")
		desc = "no description available";
	return (isin+" ("+desc+")");
}

using QuantLib::Instruments::Stock;

InstrumentHandle NewStock(String isinCode = "", String description = "") {
	return InstrumentHandle(new Stock(isinCode,description));
}

#include "quantlib.h"

using QuantLib::Handle;
using QuantLib::Math::Interpolation;
using QuantLib::Array;
typedef Handle<Interpolation<Array::const_iterator, Array::const_iterator> > InterpolationHandle;
using QuantLib::IsNull;

using QuantLib::Math::LinearInterpolation;
using QuantLib::Math::CubicSpline;

InterpolationHandle NewLinearInterpolation(const Array& x, const Array& y) {
    return InterpolationHandle(
        new LinearInterpolation<Array::const_iterator,Array::const_iterator>(
            x.begin(),x.end(),y.begin())); }

InterpolationHandle newCubicSpline(const Array& x, const Array& y) {
    return InterpolationHandle(
        new CubicSpline<Array::const_iterator,Array::const_iterator>(
            x.begin(),x.end(),y.begin())); }

#include "quantlib.h"

#include "standardpathgenerator.h"
using QuantLib::MonteCarlo::StandardPathGenerator;

#include "mceuropeanpricer.h"
using QuantLib::Pricers::McEuropeanPricer;

#include "geometricasianoption.h"
using QuantLib::Pricers::GeometricAsianOption;

#include "mcasianpricer.h"
using QuantLib::Pricers::McAsianPricer;

#include "quantlib.h"

using QuantLib::FiniteDifferences::TridiagonalOperator;

using QuantLib::FiniteDifferences::DPlus;
using QuantLib::FiniteDifferences::DMinus;
using QuantLib::FiniteDifferences::DZero;
using QuantLib::FiniteDifferences::DPlusDMinus;

#include "quantlib.h"

using QuantLib::Option;
typedef Option::Type OptionType;
using QuantLib::StringFormatter;

#include "quantlib.h"

using QuantLib::Pricers::BSMEuropeanOption;
using QuantLib::Pricers::BSMAmericanOption;
using QuantLib::Pricers::DividendAmericanOption;
using QuantLib::Pricers::DividendEuropeanOption;

#include "quantlib.h"

using QuantLib::MonteCarlo::UniformRandomGenerator;
using QuantLib::MonteCarlo::GaussianRandomGenerator;

#include "quantlib.h"
#include "risktool.h"

using QuantLib::RiskTool::RiskTool;

#include "quantlib.h"

using QuantLib::ObjectiveFunction;

// its C++ container
class PyObjectiveFunction : public ObjectiveFunction {
  public:
	PyObjectiveFunction(PyObject *pyFunction) : thePyFunction(pyFunction) {}
	double value(double x) const {
		PyObject* pyResult = PyObject_CallMethod(thePyFunction,"value","d",x);
		QL_ENSURE(pyResult != NULL, "failed to call value() on Python object");
		double result = PyFloat_AsDouble(pyResult);
		Py_XDECREF(pyResult);
		return result;
	}
	double derivative(double x) const {
		PyObject* pyResult = 
		  PyObject_CallMethod(thePyFunction,"derivative","d",x);
		QL_ENSURE(pyResult != NULL,
		  "failed to call derivative() on Python object");
		double result = PyFloat_AsDouble(pyResult);
		Py_XDECREF(pyResult);
		return result;
	}
  private:
	PyObject* thePyFunction;
};

using QuantLib::Solver1D;

using QuantLib::Solvers1D::Bisection;
using QuantLib::Solvers1D::Brent;
using QuantLib::Solvers1D::FalsePosition;
using QuantLib::Solvers1D::Newton;
using QuantLib::Solvers1D::NewtonSafe;
using QuantLib::Solvers1D::Ridder;
using QuantLib::Solvers1D::Secant;

#include "quantlib.h"

using QuantLib::Math::Statistics;
static PyObject *_wrap_DateFromSerialNumber(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    int  _arg0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"i:DateFromSerialNumber",&_arg0)) 
        return NULL;
{
	try {
		    _result = new Date (DateFromSerialNumber(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_TARGET(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CalendarHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":TARGET")) 
        return NULL;
{
	try {
		    _result = new CalendarHandle (NewTARGET());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CalendarHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_NewYork(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CalendarHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":NewYork")) 
        return NULL;
{
	try {
		    _result = new CalendarHandle (NewNewYork());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CalendarHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_London(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CalendarHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":London")) 
        return NULL;
{
	try {
		    _result = new CalendarHandle (NewLondon());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CalendarHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_Frankfurt(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CalendarHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":Frankfurt")) 
        return NULL;
{
	try {
		    _result = new CalendarHandle (NewFrankfurt());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CalendarHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_Milan(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CalendarHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":Milan")) 
        return NULL;
{
	try {
		    _result = new CalendarHandle (NewMilan());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CalendarHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_Zurich(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CalendarHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":Zurich")) 
        return NULL;
{
	try {
		    _result = new CalendarHandle (NewZurich());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CalendarHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_EUR(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CurrencyHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":EUR")) 
        return NULL;
{
	try {
		    _result = new CurrencyHandle (NewEUR());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CurrencyHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_USD(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CurrencyHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":USD")) 
        return NULL;
{
	try {
		    _result = new CurrencyHandle (NewUSD());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CurrencyHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_GBP(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CurrencyHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":GBP")) 
        return NULL;
{
	try {
		    _result = new CurrencyHandle (NewGBP());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CurrencyHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_DEM(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CurrencyHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":DEM")) 
        return NULL;
{
	try {
		    _result = new CurrencyHandle (NewDEM());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CurrencyHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_ITL(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CurrencyHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":ITL")) 
        return NULL;
{
	try {
		    _result = new CurrencyHandle (NewITL());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CurrencyHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_AUD(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CurrencyHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":AUD")) 
        return NULL;
{
	try {
		    _result = new CurrencyHandle (NewAUD());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CurrencyHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_CAD(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CurrencyHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":CAD")) 
        return NULL;
{
	try {
		    _result = new CurrencyHandle (NewCAD());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CurrencyHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_CHF(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CurrencyHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":CHF")) 
        return NULL;
{
	try {
		    _result = new CurrencyHandle (NewCHF());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CurrencyHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_DKK(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CurrencyHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":DKK")) 
        return NULL;
{
	try {
		    _result = new CurrencyHandle (NewDKK());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CurrencyHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_JPY(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CurrencyHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":JPY")) 
        return NULL;
{
	try {
		    _result = new CurrencyHandle (NewJPY());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CurrencyHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_SEK(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CurrencyHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":SEK")) 
        return NULL;
{
	try {
		    _result = new CurrencyHandle (NewSEK());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CurrencyHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_Actual360(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DayCounterHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":Actual360")) 
        return NULL;
{
	try {
		    _result = new DayCounterHandle (NewActual360());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_DayCounterHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_Actual365(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DayCounterHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":Actual365")) 
        return NULL;
{
	try {
		    _result = new DayCounterHandle (NewActual365());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_DayCounterHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_Thirty360(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DayCounterHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":Thirty360")) 
        return NULL;
{
	try {
		    _result = new DayCounterHandle (NewThirty360());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_DayCounterHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_Thirty360European(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DayCounterHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":Thirty360European")) 
        return NULL;
{
	try {
		    _result = new DayCounterHandle (NewThirty360European());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_DayCounterHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_Thirty360Italian(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DayCounterHandle * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":Thirty360Italian")) 
        return NULL;
{
	try {
		    _result = new DayCounterHandle (NewThirty360Italian());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_DayCounterHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_LexicographicalView(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ArrayLexicographicalView * _result;
    Array * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"si:LexicographicalView",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Array_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of LexicographicalView. Expected _Array_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new ArrayLexicographicalView (CreateLexicographicView(*_arg0,_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_ArrayLexicographicalView_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_ImpliedTermStructure(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TermStructureHandle * _result;
    TermStructureHandle * _arg0;
    Date * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"ss:ImpliedTermStructure",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ImpliedTermStructure. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of ImpliedTermStructure. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new TermStructureHandle (NewImpliedTermStructure(*_arg0,*_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_TermStructureHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_SpreadedTermStructure(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TermStructureHandle * _result;
    TermStructureHandle * _arg0;
    Spread  _arg1;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"sd:SpreadedTermStructure",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of SpreadedTermStructure. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new TermStructureHandle (NewSpreadedTermStructure(*_arg0,_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_TermStructureHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_FlatForward(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TermStructureHandle * _result;
    CurrencyHandle * _arg0;
    DayCounterHandle * _arg1;
    Date * _arg2;
    Rate  _arg3;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"sssd:FlatForward",&_argc0,&_argc1,&_argc2,&_arg3)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CurrencyHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of FlatForward. Expected _CurrencyHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_DayCounterHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of FlatForward. Expected _DayCounterHandle_p.");
        return NULL;
        }
    }
    if (_argc2) {
        if (SWIG_GetPtr(_argc2,(void **) &_arg2,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 3 of FlatForward. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new TermStructureHandle (NewFlatForward(*_arg0,*_arg1,*_arg2,_arg3));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_TermStructureHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_PiecewiseConstantForwards(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TermStructureHandle * _result;
    CurrencyHandle * _arg0;
    DayCounterHandle * _arg1;
    Date * _arg2;
    DepositList * _arg3;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;
    PyObject * _obj3 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"sssO:PiecewiseConstantForwards",&_argc0,&_argc1,&_argc2,&_obj3)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CurrencyHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of PiecewiseConstantForwards. Expected _CurrencyHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_DayCounterHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of PiecewiseConstantForwards. Expected _DayCounterHandle_p.");
        return NULL;
        }
    }
    if (_argc2) {
        if (SWIG_GetPtr(_argc2,(void **) &_arg2,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 3 of PiecewiseConstantForwards. Expected _Date_p.");
        return NULL;
        }
    }
{
	if (PyTuple_Check(_obj3)) {
		int size = PyTuple_Size(_obj3);
		_arg3 = new std::vector<Deposit>(size);
		for (int i=0; i<size; i++) {
			Deposit* d;
			PyObject* o = PyTuple_GetItem(_obj3,i);
			if ((SWIG_ConvertPtr(o,(void **) &d,
			  (swig_type_info *)SWIG_TypeQuery("Deposit *"),1)) != -1) {
				(*_arg3)[i] = *d;
			} else {
				PyErr_SetString(PyExc_TypeError,"tuple must contain deposits");
				delete _arg3;
				return NULL;
			}
		}
	} else if (PyList_Check(_obj3)) {
		int size = PyList_Size(_obj3);
		_arg3 = new std::vector<Deposit>(size);
		for (int i=0; i<size; i++) {
			Deposit* d;
			PyObject* o = PyList_GetItem(_obj3,i);
			if ((SWIG_ConvertPtr(o,(void **) &d,
			  (swig_type_info *)SWIG_TypeQuery("Deposit *"),1)) != -1) {
				(*_arg3)[i] = *d;
			} else {
				PyErr_SetString(PyExc_TypeError,"list must contain deposits");
				delete _arg3;
				return NULL;
			}
		}
	} else {
		PyErr_SetString(PyExc_TypeError,"not a sequence");
		return NULL;
	}
}
{
	try {
		    _result = new TermStructureHandle (NewPiecewiseConstantForwards(*_arg0,*_arg1,*_arg2,*_arg3));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_TermStructureHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
{
	delete _arg3;
}
    return _resultobj;
}

static PyObject *_wrap_Stock(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    InstrumentHandle * _result;
    String * _arg0 = &"";
    String * _arg1 = &"";
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"|OO:Stock",&_obj0,&_obj1)) 
        return NULL;
    if (_obj0)
{
	if (PyString_Check(_obj0)) {
		_arg0 = new std::string(PyString_AsString(_obj0));
	} else {
		PyErr_SetString(PyExc_TypeError,"not a string");
		return NULL;
	}
}
    if (_obj1)
{
	if (PyString_Check(_obj1)) {
		_arg1 = new std::string(PyString_AsString(_obj1));
	} else {
		PyErr_SetString(PyExc_TypeError,"not a string");
		return NULL;
	}
}
{
	try {
		    _result = new InstrumentHandle (NewStock(*_arg0,*_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_InstrumentHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
{
	delete _arg0;
}
{
	delete _arg1;
}
    return _resultobj;
}

static PyObject *_wrap_LinearInterpolation(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    InterpolationHandle * _result;
    Array * _arg0;
    Array * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"ss:LinearInterpolation",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Array_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of LinearInterpolation. Expected _Array_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Array_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of LinearInterpolation. Expected _Array_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new InterpolationHandle (NewLinearInterpolation(*_arg0,*_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_InterpolationHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_CubicSpline(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    InterpolationHandle * _result;
    Array * _arg0;
    Array * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"ss:CubicSpline",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Array_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of CubicSpline. Expected _Array_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Array_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of CubicSpline. Expected _Array_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new InterpolationHandle (newCubicSpline(*_arg0,*_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_InterpolationHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define new_BoundaryCondition(_swigarg0,_swigarg1) (new BoundaryCondition(_swigarg0,_swigarg1))
static PyObject *_wrap_new_BoundaryCondition(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BoundaryCondition * _result;
    BoundaryConditionType * _arg0;
    double  _arg1;
    PyObject * _obj0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"Od:new_BoundaryCondition",&_obj0,&_arg1)) 
        return NULL;
{
	if (PyString_Check(_obj0)) {
		std::string s(PyString_AsString(_obj0));
		s = StringFormatter::toLowercase(s);
		if (s == "" || s == "none")
		    _arg0 = new BoundaryConditionType(BoundaryCondition::None);
		else if (s == "neumann")
		    _arg0 = new BoundaryConditionType(BoundaryCondition::Neumann);
		else if (s == "dirichlet")
		    _arg0 = new BoundaryConditionType(BoundaryCondition::Dirichlet);
		else {
			PyErr_SetString(PyExc_TypeError,"not a boundary condition type");
			return NULL;
		}
	} else {
		PyErr_SetString(PyExc_TypeError,"not a boundary condition type");
		return NULL;
	}
}
{
	try {
		    _result = (BoundaryCondition *)new_BoundaryCondition(*_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_BoundaryCondition_p");
    _resultobj = Py_BuildValue("s",_ptemp);
{
	delete _arg0;
}
    return _resultobj;
}

#define delete_BoundaryCondition(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_BoundaryCondition(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BoundaryCondition * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_BoundaryCondition",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BoundaryCondition_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_BoundaryCondition. Expected _BoundaryCondition_p.");
        return NULL;
        }
    }
{
	try {
		    delete_BoundaryCondition(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define BoundaryCondition_type(_swigobj)  (_swigobj->type())
static PyObject *_wrap_BoundaryCondition_type(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BoundaryConditionType * _result;
    BoundaryCondition * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:BoundaryCondition_type",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BoundaryCondition_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BoundaryCondition_type. Expected _BoundaryCondition_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new BoundaryConditionType (BoundaryCondition_type(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	switch (*_result) {
	  case BoundaryCondition::None:
	    _resultobj = PyString_FromString("None");
	    break;
	  case BoundaryCondition::Neumann:
	    _resultobj = PyString_FromString("Neumann");
	    break;
	  case BoundaryCondition::Dirichlet:
	    _resultobj = PyString_FromString("Dirichlet");
	    break;
	}
}
{
	delete _result;
}
    return _resultobj;
}

#define BoundaryCondition_value(_swigobj)  (_swigobj->value())
static PyObject *_wrap_BoundaryCondition_value(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BoundaryCondition * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:BoundaryCondition_value",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BoundaryCondition_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BoundaryCondition_value. Expected _BoundaryCondition_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BoundaryCondition_value(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define new_Date(_swigarg0,_swigarg1,_swigarg2) (new Date(_swigarg0,_swigarg1,_swigarg2))
static PyObject *_wrap_new_Date(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    Day  _arg0;
    Month * _arg1;
    Year  _arg2;
    PyObject * _obj1 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"iOi:new_Date",&_arg0,&_obj1,&_arg2)) 
        return NULL;
{
	if (PyString_Check(_obj1)) {
		std::string s(PyString_AsString(_obj1));
		s = StringFormatter::toLowercase(s);
		if (s == "jan" || s == "january")
		    _arg1 = new Month(January);
		else if (s == "feb" || s == "february")
		    _arg1 = new Month(February);
		else if (s == "mar" || s == "march")
		    _arg1 = new Month(March);
		else if (s == "apr" || s == "april")
		    _arg1 = new Month(April);
		else if (s == "may")
		    _arg1 = new Month(May);
		else if (s == "jun" || s == "june")
		    _arg1 = new Month(June);
		else if (s == "jul" || s == "july")
		    _arg1 = new Month(July);
		else if (s == "aug" || s == "august")
		    _arg1 = new Month(August);
		else if (s == "sep" || s == "september")
		    _arg1 = new Month(September);
		else if (s == "oct" || s == "october")
		    _arg1 = new Month(October);
		else if (s == "nov" || s == "november")
		    _arg1 = new Month(November);
		else if (s == "dec" || s == "december")
		    _arg1 = new Month(December);
		else {
			PyErr_SetString(PyExc_TypeError,"not a month");
			return NULL;
		}
	} else if (PyInt_Check(_obj1)) {
		int i = int(PyInt_AsLong(_obj1));
		if (i>=1 && i<=12)
			_arg1 = new Month(Month(i));
		else {
			PyErr_SetString(PyExc_TypeError,"not a month");
			return NULL;
		}
	} else {
		PyErr_SetString(PyExc_TypeError,"not a weekday");
		return NULL;
	}
}
{
	try {
		    _result = (Date *)new_Date(_arg0,*_arg1,_arg2);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
{
	delete _arg1;
}
    return _resultobj;
}

#define delete_Date(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_Date(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_Date",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_Date. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    delete_Date(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define Date_weekday(_swigobj)  (_swigobj->weekday())
static PyObject *_wrap_Date_weekday(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Weekday * _result;
    Date * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Date_weekday",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date_weekday. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Weekday (Date_weekday(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	switch (*_result) {
	  case Sunday:		_resultobj = PyString_FromString("Sunday");	break;
	  case Monday:		_resultobj = PyString_FromString("Monday");	break;
	  case Tuesday:		_resultobj = PyString_FromString("Tuesday");	break;
	  case Wednesday:	_resultobj = PyString_FromString("Wednesday");	break;
	  case Thursday:	_resultobj = PyString_FromString("Thursday");	break;
	  case Friday:		_resultobj = PyString_FromString("Friday");	break;
	  case Saturday:	_resultobj = PyString_FromString("Saturday");	break;
	}
}
{
	delete _result;
}
    return _resultobj;
}

#define Date_dayOfMonth(_swigobj)  (_swigobj->dayOfMonth())
static PyObject *_wrap_Date_dayOfMonth(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Day  _result;
    Date * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Date_dayOfMonth",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date_dayOfMonth. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (Day )Date_dayOfMonth(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define Date_dayOfYear(_swigobj)  (_swigobj->dayOfYear())
static PyObject *_wrap_Date_dayOfYear(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Day  _result;
    Date * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Date_dayOfYear",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date_dayOfYear. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (Day )Date_dayOfYear(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define Date_month(_swigobj)  (_swigobj->month())
static PyObject *_wrap_Date_month(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Month * _result;
    Date * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Date_month",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date_month. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Month (Date_month(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	switch (*_result) {
	  case January:		_resultobj = PyString_FromString("January");	break;
	  case February:	_resultobj = PyString_FromString("February");	break;
	  case March:		_resultobj = PyString_FromString("March");		break;
	  case April:		_resultobj = PyString_FromString("April");		break;
	  case May:			_resultobj = PyString_FromString("May");		break;
	  case June:		_resultobj = PyString_FromString("June");		break;
	  case July:		_resultobj = PyString_FromString("July");		break;
	  case August:		_resultobj = PyString_FromString("August");	break;
	  case September:	_resultobj = PyString_FromString("September");	break;
	  case October:		_resultobj = PyString_FromString("October");	break;
	  case November:	_resultobj = PyString_FromString("November");	break;
	  case December:	_resultobj = PyString_FromString("December");	break;
	}
}
{
	delete _result;
}
    return _resultobj;
}

#define Date_year(_swigobj)  (_swigobj->year())
static PyObject *_wrap_Date_year(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Year  _result;
    Date * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Date_year",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date_year. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (Year )Date_year(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define Date_serialNumber(_swigobj)  (_swigobj->serialNumber())
static PyObject *_wrap_Date_serialNumber(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    Date * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Date_serialNumber",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date_serialNumber. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )Date_serialNumber(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define Date_plusDays(_swigobj,_swigarg0)  (_swigobj->plusDays(_swigarg0))
static PyObject *_wrap_Date_plusDays(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    Date * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"si:Date_plusDays",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date_plusDays. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (Date_plusDays(_arg0,_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define Date_plusWeeks(_swigobj,_swigarg0)  (_swigobj->plusWeeks(_swigarg0))
static PyObject *_wrap_Date_plusWeeks(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    Date * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"si:Date_plusWeeks",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date_plusWeeks. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (Date_plusWeeks(_arg0,_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define Date_plusMonths(_swigobj,_swigarg0)  (_swigobj->plusMonths(_swigarg0))
static PyObject *_wrap_Date_plusMonths(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    Date * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"si:Date_plusMonths",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date_plusMonths. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (Date_plusMonths(_arg0,_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define Date_plusYears(_swigobj,_swigarg0)  (_swigobj->plusYears(_swigarg0))
static PyObject *_wrap_Date_plusYears(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    Date * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"si:Date_plusYears",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date_plusYears. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (Date_plusYears(_arg0,_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define Date_plus(_swigobj,_swigarg0,_swigarg1)  (_swigobj->plus(_swigarg0,_swigarg1))
static PyObject *_wrap_Date_plus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    Date * _arg0;
    int  _arg1;
    TimeUnit * _arg2;
    char * _argc0 = 0;
    PyObject * _obj2 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"siO:Date_plus",&_argc0,&_arg1,&_obj2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date_plus. Expected _Date_p.");
        return NULL;
        }
    }
{
	if (PyString_Check(_obj2)) {
		std::string s(PyString_AsString(_obj2));
		s = StringFormatter::toLowercase(s);
		if (s == "d" || s == "day" || s == "days")
		    _arg2 = new TimeUnit(Days);
		else if (s == "w" || s == "week" || s == "weeks")
		    _arg2 = new TimeUnit(Weeks);
		else if (s == "m" || s == "month" || s == "months")
		    _arg2 = new TimeUnit(Months);
		else if (s == "y" || s == "year" || s == "years")
		    _arg2 = new TimeUnit(Years);
		else {
			PyErr_SetString(PyExc_TypeError,"unknown time unit");
			return NULL;
		}
	} else {
		PyErr_SetString(PyExc_TypeError,"not a time unit");
		return NULL;
	}
}
{
	try {
		    _result = new Date (Date_plus(_arg0,_arg1,*_arg2));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
{
	delete _arg2;
}
    return _resultobj;
}

static PyObject *_wrap_Date_isLeap(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    bool  _result;
    Year  _arg0;

    self = self;
    if(!PyArg_ParseTuple(args,"i:Date_isLeap",&_arg0)) 
        return NULL;
{
	try {
		    _result = (bool )Date::isLeap(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static PyObject *_wrap_Date_minDate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":Date_minDate")) 
        return NULL;
{
	try {
		    _result = new Date (Date::minDate());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static PyObject *_wrap_Date_maxDate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":Date_maxDate")) 
        return NULL;
{
	try {
		    _result = new Date (Date::maxDate());

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static int  Date_monthNumber(Date *self) {
		return int(self->month());
	}
static PyObject *_wrap_Date_monthNumber(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    Date * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Date_monthNumber",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date_monthNumber. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )Date_monthNumber(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static int  Date_weekdayNumber(Date *self) {
		return int(self->weekday());
	}
static PyObject *_wrap_Date_weekdayNumber(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    Date * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Date_weekdayNumber",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date_weekdayNumber. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )Date_weekdayNumber(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static Date  Date___add__(Date *self,int  days) {
		return self->plusDays(days);
	}
static PyObject *_wrap_Date___add__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    Date * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"si:Date___add__",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date___add__. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (Date___add__(_arg0,_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static Date  Date___sub__(Date *self,int  days) {
		return self->plusDays(-days);
	}
static PyObject *_wrap_Date___sub__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    Date * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"si:Date___sub__",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date___sub__. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (Date___sub__(_arg0,_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static int  Date___cmp__(Date *self,const Date & other) {
		if (*self < other)
			return -1;
		if (*self == other)
			return 0;
		return 1;
	}
static PyObject *_wrap_Date___cmp__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    Date * _arg0;
    Date * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:Date___cmp__",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date___cmp__. Expected _Date_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of Date___cmp__. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )Date___cmp__(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static String  Date___str__(Date *self) {
		return DateFormatter::toString(*self);
	}
static PyObject *_wrap_Date___str__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    Date * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Date___str__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date___str__. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (Date___str__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

static String  Date___repr__(Date *self) {
		return "<Date: "+DateFormatter::toString(*self)+">";
	}
static PyObject *_wrap_Date___repr__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    Date * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Date___repr__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Date___repr__. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (Date___repr__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

#define delete_CalendarHandle(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_Calendar(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CalendarHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_Calendar",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CalendarHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_Calendar. Expected _CalendarHandle_p.");
        return NULL;
        }
    }
{
	try {
		    delete_CalendarHandle(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static bool  CalendarHandle_isBusinessDay(CalendarHandle *self,const Date & d) {
		return (*self)->isBusinessDay(d);
	}
static PyObject *_wrap_Calendar_isBusinessDay(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    bool  _result;
    CalendarHandle * _arg0;
    Date * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:Calendar_isBusinessDay",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CalendarHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Calendar_isBusinessDay. Expected _CalendarHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of Calendar_isBusinessDay. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (bool )CalendarHandle_isBusinessDay(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static bool  CalendarHandle_isHoliday(CalendarHandle *self,const Date & d) {
		return (*self)->isHoliday(d);
	}
static PyObject *_wrap_Calendar_isHoliday(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    bool  _result;
    CalendarHandle * _arg0;
    Date * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:Calendar_isHoliday",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CalendarHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Calendar_isHoliday. Expected _CalendarHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of Calendar_isHoliday. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (bool )CalendarHandle_isHoliday(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static Date  CalendarHandle_roll(CalendarHandle *self,const Date & d,bool  modified) {
		return (*self)->roll(d,modified);
	}
static PyObject *_wrap_Calendar_roll(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    CalendarHandle * _arg0;
    Date * _arg1;
    bool  _arg2 = false;
    char * _argc0 = 0;
    char * _argc1 = 0;
    int tempbool2;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"ss|i:Calendar_roll",&_argc0,&_argc1,&tempbool2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CalendarHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Calendar_roll. Expected _CalendarHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of Calendar_roll. Expected _Date_p.");
        return NULL;
        }
    }
    _arg2 = (bool ) tempbool2;
{
	try {
		    _result = new Date (CalendarHandle_roll(_arg0,*_arg1,_arg2));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static Date  CalendarHandle_advance(CalendarHandle *self,const Date & d,int  n,TimeUnit  unit,bool  modified) {
		return (*self)->advance(d,n,unit,modified);
	}
static PyObject *_wrap_Calendar_advance(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    CalendarHandle * _arg0;
    Date * _arg1;
    int  _arg2;
    TimeUnit * _arg3;
    bool  _arg4 = false;
    char * _argc0 = 0;
    char * _argc1 = 0;
    PyObject * _obj3 = 0;
    int tempbool4;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"ssiO|i:Calendar_advance",&_argc0,&_argc1,&_arg2,&_obj3,&tempbool4)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CalendarHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Calendar_advance. Expected _CalendarHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of Calendar_advance. Expected _Date_p.");
        return NULL;
        }
    }
{
	if (PyString_Check(_obj3)) {
		std::string s(PyString_AsString(_obj3));
		s = StringFormatter::toLowercase(s);
		if (s == "d" || s == "day" || s == "days")
		    _arg3 = new TimeUnit(Days);
		else if (s == "w" || s == "week" || s == "weeks")
		    _arg3 = new TimeUnit(Weeks);
		else if (s == "m" || s == "month" || s == "months")
		    _arg3 = new TimeUnit(Months);
		else if (s == "y" || s == "year" || s == "years")
		    _arg3 = new TimeUnit(Years);
		else {
			PyErr_SetString(PyExc_TypeError,"unknown time unit");
			return NULL;
		}
	} else {
		PyErr_SetString(PyExc_TypeError,"not a time unit");
		return NULL;
	}
}
    _arg4 = (bool ) tempbool4;
{
	try {
		    _result = new Date (CalendarHandle_advance(_arg0,*_arg1,_arg2,*_arg3,_arg4));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
{
	delete _arg3;
}
    return _resultobj;
}

static String  CalendarHandle___str__(CalendarHandle *self) {
		return (*self)->name()+" calendar";
	}
static PyObject *_wrap_Calendar___str__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    CalendarHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Calendar___str__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CalendarHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Calendar___str__. Expected _CalendarHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (CalendarHandle___str__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

static String  CalendarHandle___repr__(CalendarHandle *self) {
		return "<"+(*self)->name()+" calendar>";
	}
static PyObject *_wrap_Calendar___repr__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    CalendarHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Calendar___repr__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CalendarHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Calendar___repr__. Expected _CalendarHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (CalendarHandle___repr__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

static int  CalendarHandle___cmp__(CalendarHandle *self,const CalendarHandle & other) {
		return ((*self) == other ? 0 : 1);
	}
static PyObject *_wrap_Calendar___cmp__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    CalendarHandle * _arg0;
    CalendarHandle * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:Calendar___cmp__",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CalendarHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Calendar___cmp__. Expected _CalendarHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_CalendarHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of Calendar___cmp__. Expected _CalendarHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )CalendarHandle___cmp__(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static int  CalendarHandle___nonzero__(CalendarHandle *self) {
		return (IsNull(*self) ? 0 : 1);
	}
static PyObject *_wrap_Calendar___nonzero__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    CalendarHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Calendar___nonzero__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CalendarHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Calendar___nonzero__. Expected _CalendarHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )CalendarHandle___nonzero__(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define delete_CurrencyHandle(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_Currency(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CurrencyHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_Currency",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CurrencyHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_Currency. Expected _CurrencyHandle_p.");
        return NULL;
        }
    }
{
	try {
		    delete_CurrencyHandle(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static CalendarHandle  CurrencyHandle_settlementCalendar(CurrencyHandle *self) {
		return (*self)->settlementCalendar();
	}
static PyObject *_wrap_Currency_settlementCalendar(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CalendarHandle * _result;
    CurrencyHandle * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:Currency_settlementCalendar",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CurrencyHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Currency_settlementCalendar. Expected _CurrencyHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new CalendarHandle (CurrencyHandle_settlementCalendar(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CalendarHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static int  CurrencyHandle_settlementDays(CurrencyHandle *self) {
		return (*self)->settlementDays();
	}
static PyObject *_wrap_Currency_settlementDays(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    CurrencyHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Currency_settlementDays",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CurrencyHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Currency_settlementDays. Expected _CurrencyHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )CurrencyHandle_settlementDays(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static Date  CurrencyHandle_settlementDate(CurrencyHandle *self,const Date & d) {
		return (*self)->settlementDate(d);
	}
static PyObject *_wrap_Currency_settlementDate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    CurrencyHandle * _arg0;
    Date * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"ss:Currency_settlementDate",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CurrencyHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Currency_settlementDate. Expected _CurrencyHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of Currency_settlementDate. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (CurrencyHandle_settlementDate(_arg0,*_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static String  CurrencyHandle___str__(CurrencyHandle *self) {
		return (*self)->name()+" currency";
	}
static PyObject *_wrap_Currency___str__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    CurrencyHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Currency___str__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CurrencyHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Currency___str__. Expected _CurrencyHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (CurrencyHandle___str__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

static String  CurrencyHandle___repr__(CurrencyHandle *self) {
		return "<"+(*self)->name()+" currency>";
	}
static PyObject *_wrap_Currency___repr__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    CurrencyHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Currency___repr__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CurrencyHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Currency___repr__. Expected _CurrencyHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (CurrencyHandle___repr__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

static int  CurrencyHandle___cmp__(CurrencyHandle *self,const CurrencyHandle & other) {
		return ((*self) == other ? 0 : 1);
	}
static PyObject *_wrap_Currency___cmp__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    CurrencyHandle * _arg0;
    CurrencyHandle * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:Currency___cmp__",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CurrencyHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Currency___cmp__. Expected _CurrencyHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_CurrencyHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of Currency___cmp__. Expected _CurrencyHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )CurrencyHandle___cmp__(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static int  CurrencyHandle___nonzero__(CurrencyHandle *self) {
		return (IsNull(*self) ? 0 : 1);
	}
static PyObject *_wrap_Currency___nonzero__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    CurrencyHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Currency___nonzero__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CurrencyHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Currency___nonzero__. Expected _CurrencyHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )CurrencyHandle___nonzero__(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define delete_DayCounterHandle(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_DayCounter(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DayCounterHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_DayCounter",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DayCounterHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_DayCounter. Expected _DayCounterHandle_p.");
        return NULL;
        }
    }
{
	try {
		    delete_DayCounterHandle(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static int  DayCounterHandle_dayCount(DayCounterHandle *self,const Date & d1,const Date & d2) {
		return (*self)->dayCount(d1,d2);
	}
static PyObject *_wrap_DayCounter_dayCount(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    DayCounterHandle * _arg0;
    Date * _arg1;
    Date * _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sss:DayCounter_dayCount",&_argc0,&_argc1,&_argc2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DayCounterHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DayCounter_dayCount. Expected _DayCounterHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of DayCounter_dayCount. Expected _Date_p.");
        return NULL;
        }
    }
    if (_argc2) {
        if (SWIG_GetPtr(_argc2,(void **) &_arg2,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 3 of DayCounter_dayCount. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )DayCounterHandle_dayCount(_arg0,*_arg1,*_arg2);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static Time  DayCounterHandle_yearFraction(DayCounterHandle *self,const Date & d1,const Date & d2) {
		return (*self)->yearFraction(d1,d2);
	}
static PyObject *_wrap_DayCounter_yearFraction(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Time  _result;
    DayCounterHandle * _arg0;
    Date * _arg1;
    Date * _arg2;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char * _argc2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sss:DayCounter_yearFraction",&_argc0,&_argc1,&_argc2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DayCounterHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DayCounter_yearFraction. Expected _DayCounterHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of DayCounter_yearFraction. Expected _Date_p.");
        return NULL;
        }
    }
    if (_argc2) {
        if (SWIG_GetPtr(_argc2,(void **) &_arg2,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 3 of DayCounter_yearFraction. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (Time )DayCounterHandle_yearFraction(_arg0,*_arg1,*_arg2);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static String  DayCounterHandle___str__(DayCounterHandle *self) {
		return (*self)->name()+" day counter";
	}
static PyObject *_wrap_DayCounter___str__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    DayCounterHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DayCounter___str__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DayCounterHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DayCounter___str__. Expected _DayCounterHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (DayCounterHandle___str__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

static String  DayCounterHandle___repr__(DayCounterHandle *self) {
		return "<"+(*self)->name()+" day counter>";
	}
static PyObject *_wrap_DayCounter___repr__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    DayCounterHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DayCounter___repr__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DayCounterHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DayCounter___repr__. Expected _DayCounterHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (DayCounterHandle___repr__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

static int  DayCounterHandle___cmp__(DayCounterHandle *self,const DayCounterHandle & other) {
		return ((*self) == other ? 0 : 1);
	}
static PyObject *_wrap_DayCounter___cmp__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    DayCounterHandle * _arg0;
    DayCounterHandle * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:DayCounter___cmp__",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DayCounterHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DayCounter___cmp__. Expected _DayCounterHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_DayCounterHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of DayCounter___cmp__. Expected _DayCounterHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )DayCounterHandle___cmp__(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static int  DayCounterHandle___nonzero__(DayCounterHandle *self) {
		return (IsNull(*self) ? 0 : 1);
	}
static PyObject *_wrap_DayCounter___nonzero__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    DayCounterHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DayCounter___nonzero__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DayCounterHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DayCounter___nonzero__. Expected _DayCounterHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )DayCounterHandle___nonzero__(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define new_NormalDistribution(_swigarg0,_swigarg1) (new NormalDistribution(_swigarg0,_swigarg1))
static PyObject *_wrap_new_NormalDistribution(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    NormalDistribution * _result;
    double  _arg0 = 0.0;
    double  _arg1 = 1.0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"|dd:new_NormalDistribution",&_arg0,&_arg1)) 
        return NULL;
{
	try {
		    _result = (NormalDistribution *)new_NormalDistribution(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_NormalDistribution_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_NormalDistribution(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_NormalDistribution(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    NormalDistribution * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_NormalDistribution",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_NormalDistribution_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_NormalDistribution. Expected _NormalDistribution_p.");
        return NULL;
        }
    }
{
	try {
		    delete_NormalDistribution(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define NormalDistribution_derivative(_swigobj,_swigarg0)  (_swigobj->derivative(_swigarg0))
static PyObject *_wrap_NormalDistribution_derivative(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    NormalDistribution * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:NormalDistribution_derivative",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_NormalDistribution_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of NormalDistribution_derivative. Expected _NormalDistribution_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )NormalDistribution_derivative(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  NormalDistribution___call__(NormalDistribution *self,double  x) {
        return (*self)(x);
    }
static PyObject *_wrap_NormalDistribution___call__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    NormalDistribution * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:NormalDistribution___call__",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_NormalDistribution_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of NormalDistribution___call__. Expected _NormalDistribution_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )NormalDistribution___call__(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define new_CumulativeNormalDistribution(_swigarg0,_swigarg1) (new CumulativeNormalDistribution(_swigarg0,_swigarg1))
static PyObject *_wrap_new_CumulativeNormalDistribution(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CumulativeNormalDistribution * _result;
    double  _arg0 = 0.0;
    double  _arg1 = 1.0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"|dd:new_CumulativeNormalDistribution",&_arg0,&_arg1)) 
        return NULL;
{
	try {
		    _result = (CumulativeNormalDistribution *)new_CumulativeNormalDistribution(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_CumulativeNormalDistribution_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_CumulativeNormalDistribution(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_CumulativeNormalDistribution(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CumulativeNormalDistribution * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_CumulativeNormalDistribution",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CumulativeNormalDistribution_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_CumulativeNormalDistribution. Expected _CumulativeNormalDistribution_p.");
        return NULL;
        }
    }
{
	try {
		    delete_CumulativeNormalDistribution(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define CumulativeNormalDistribution_derivative(_swigobj,_swigarg0)  (_swigobj->derivative(_swigarg0))
static PyObject *_wrap_CumulativeNormalDistribution_derivative(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    CumulativeNormalDistribution * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:CumulativeNormalDistribution_derivative",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CumulativeNormalDistribution_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of CumulativeNormalDistribution_derivative. Expected _CumulativeNormalDistribution_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )CumulativeNormalDistribution_derivative(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  CumulativeNormalDistribution___call__(CumulativeNormalDistribution *self,double  x) {
        return (*self)(x);
    }
static PyObject *_wrap_CumulativeNormalDistribution___call__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    CumulativeNormalDistribution * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:CumulativeNormalDistribution___call__",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_CumulativeNormalDistribution_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of CumulativeNormalDistribution___call__. Expected _CumulativeNormalDistribution_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )CumulativeNormalDistribution___call__(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define new_InvCumulativeNormalDistribution(_swigarg0,_swigarg1) (new InvCumulativeNormalDistribution(_swigarg0,_swigarg1))
static PyObject *_wrap_new_InvCumulativeNormalDistribution(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    InvCumulativeNormalDistribution * _result;
    double  _arg0 = 0.0;
    double  _arg1 = 1.0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"|dd:new_InvCumulativeNormalDistribution",&_arg0,&_arg1)) 
        return NULL;
{
	try {
		    _result = (InvCumulativeNormalDistribution *)new_InvCumulativeNormalDistribution(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_InvCumulativeNormalDistribution_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_InvCumulativeNormalDistribution(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_InvCumulativeNormalDistribution(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    InvCumulativeNormalDistribution * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_InvCumulativeNormalDistribution",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InvCumulativeNormalDistribution_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_InvCumulativeNormalDistribution. Expected _InvCumulativeNormalDistribution_p.");
        return NULL;
        }
    }
{
	try {
		    delete_InvCumulativeNormalDistribution(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static double  InvCumulativeNormalDistribution___call__(InvCumulativeNormalDistribution *self,double  x) {
        return (*self)(x);
    }
static PyObject *_wrap_InvCumulativeNormalDistribution___call__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    InvCumulativeNormalDistribution * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:InvCumulativeNormalDistribution___call__",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InvCumulativeNormalDistribution_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of InvCumulativeNormalDistribution___call__. Expected _InvCumulativeNormalDistribution_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )InvCumulativeNormalDistribution___call__(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define new_Array(_swigarg0,_swigarg1) (new Array(_swigarg0,_swigarg1))
static PyObject *_wrap_new_Array(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Array * _result;
    int  _arg0;
    double  _arg1 = 0.0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"i|d:new_Array",&_arg0,&_arg1)) 
        return NULL;
{
	try {
		    _result = (Array *)new_Array(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_Array_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_Array(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_Array(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Array * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_Array",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Array_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_Array. Expected _Array_p.");
        return NULL;
        }
    }
{
	try {
		    delete_Array(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define Array_size(_swigobj)  (_swigobj->size())
static PyObject *_wrap_Array_size(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    Array * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Array_size",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Array_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Array_size. Expected _Array_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )Array_size(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static double  Array___getitem__(Array *self,int  i) {
        return (*self)[i];
    }
static PyObject *_wrap_Array___getitem__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Array * _arg0;
    int  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"si:Array___getitem__",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Array_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Array___getitem__. Expected _Array_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )Array___getitem__(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static void  Array___setitem__(Array *self,int  i,double  x) {
        (*self)[i] = x;
    }
static PyObject *_wrap_Array___setitem__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Array * _arg0;
    int  _arg1;
    double  _arg2;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sid:Array___setitem__",&_argc0,&_arg1,&_arg2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Array_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Array___setitem__. Expected _Array_p.");
        return NULL;
        }
    }
{
	try {
		    Array___setitem__(_arg0,_arg1,_arg2);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static String  Array___str__(Array *self) {
        String s = "(";
        for (int i=0; i<self->size(); i++) {
        	if (i != 0)
        		s += ",";
        	s += QuantLib::DoubleFormatter::toString((*self)[i]);
        }
        s += ")";
        return s;
    }
static PyObject *_wrap_Array___str__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    Array * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Array___str__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Array_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Array___str__. Expected _Array_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (Array___str__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

#define delete_ArrayLexicographicalView(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_ArrayLexicographicalView(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ArrayLexicographicalView * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_ArrayLexicographicalView",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ArrayLexicographicalView_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_ArrayLexicographicalView. Expected _ArrayLexicographicalView_p.");
        return NULL;
        }
    }
{
	try {
		    delete_ArrayLexicographicalView(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define ArrayLexicographicalView_xSize(_swigobj)  (_swigobj->xSize())
static PyObject *_wrap_ArrayLexicographicalView_xSize(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    ArrayLexicographicalView * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:ArrayLexicographicalView_xSize",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ArrayLexicographicalView_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ArrayLexicographicalView_xSize. Expected _ArrayLexicographicalView_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )ArrayLexicographicalView_xSize(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define ArrayLexicographicalView_ySize(_swigobj)  (_swigobj->ySize())
static PyObject *_wrap_ArrayLexicographicalView_ySize(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    ArrayLexicographicalView * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:ArrayLexicographicalView_ySize",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ArrayLexicographicalView_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ArrayLexicographicalView_ySize. Expected _ArrayLexicographicalView_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )ArrayLexicographicalView_ySize(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static ArrayLexicographicalViewColumn  ArrayLexicographicalView___getitem__(ArrayLexicographicalView *self,int  i) {
        return (*self)[i];
    }
static PyObject *_wrap_ArrayLexicographicalView___getitem__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ArrayLexicographicalViewColumn * _result;
    ArrayLexicographicalView * _arg0;
    int  _arg1;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"si:ArrayLexicographicalView___getitem__",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ArrayLexicographicalView_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ArrayLexicographicalView___getitem__. Expected _ArrayLexicographicalView_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new ArrayLexicographicalViewColumn (ArrayLexicographicalView___getitem__(_arg0,_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_ArrayLexicographicalViewColumn_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static String  ArrayLexicographicalView___str__(ArrayLexicographicalView *self) {
        String s;
        for (int j=0; j<self->ySize(); j++) {
    	    s += "\n";
            for (int i=0; i<self->xSize(); i++) {
                if (i != 0)
                    s += ",";
                s += QuantLib::DoubleFormatter::toString((*self)[i][j]);
            }
        }
        s += "\n";
        return s;
    }
static PyObject *_wrap_ArrayLexicographicalView___str__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    ArrayLexicographicalView * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:ArrayLexicographicalView___str__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ArrayLexicographicalView_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ArrayLexicographicalView___str__. Expected _ArrayLexicographicalView_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (ArrayLexicographicalView___str__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

#define delete_ArrayLexicographicalViewColumn(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_ArrayLexicographicalViewColumn(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ArrayLexicographicalViewColumn * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_ArrayLexicographicalViewColumn",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ArrayLexicographicalViewColumn_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_ArrayLexicographicalViewColumn. Expected _ArrayLexicographicalViewColumn_p.");
        return NULL;
        }
    }
{
	try {
		    delete_ArrayLexicographicalViewColumn(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static double  ArrayLexicographicalViewColumn___getitem__(ArrayLexicographicalViewColumn *self,int  i) {
        return (*self)[i];
    }
static PyObject *_wrap_ArrayLexicographicalViewColumn___getitem__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    ArrayLexicographicalViewColumn * _arg0;
    int  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"si:ArrayLexicographicalViewColumn___getitem__",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ArrayLexicographicalViewColumn_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ArrayLexicographicalViewColumn___getitem__. Expected _ArrayLexicographicalViewColumn_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )ArrayLexicographicalViewColumn___getitem__(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static void  ArrayLexicographicalViewColumn___setitem__(ArrayLexicographicalViewColumn *self,int  i,double  x) {
        (*self)[i] = x;
    }
static PyObject *_wrap_ArrayLexicographicalViewColumn___setitem__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    ArrayLexicographicalViewColumn * _arg0;
    int  _arg1;
    double  _arg2;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sid:ArrayLexicographicalViewColumn___setitem__",&_argc0,&_arg1,&_arg2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ArrayLexicographicalViewColumn_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ArrayLexicographicalViewColumn___setitem__. Expected _ArrayLexicographicalViewColumn_p.");
        return NULL;
        }
    }
{
	try {
		    ArrayLexicographicalViewColumn___setitem__(_arg0,_arg1,_arg2);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define delete_HistoryIterator(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_HistoryIterator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_HistoryIterator",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_HistoryIterator. Expected _HistoryIterator_p.");
        return NULL;
        }
    }
{
	try {
		    delete_HistoryIterator(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static Date  HistoryIterator_date(HistoryIterator *self) {
        return (*self)->date();
    }
static PyObject *_wrap_HistoryIterator_date(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    HistoryIterator * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:HistoryIterator_date",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryIterator_date. Expected _HistoryIterator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (HistoryIterator_date(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static double  HistoryIterator_value(HistoryIterator *self) {
        return (*self)->value();
    }
static PyObject *_wrap_HistoryIterator_value(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    HistoryIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:HistoryIterator_value",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryIterator_value. Expected _HistoryIterator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )HistoryIterator_value(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static void  HistoryIterator_advance(HistoryIterator *self) {
        (*self)++;
    }
static PyObject *_wrap_HistoryIterator_advance(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:HistoryIterator_advance",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryIterator_advance. Expected _HistoryIterator_p.");
        return NULL;
        }
    }
{
	try {
		    HistoryIterator_advance(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static bool  HistoryIterator___cmp__(HistoryIterator *self,const HistoryIterator & other) {
        return (*self == other ? 0 : -1);
    }
static PyObject *_wrap_HistoryIterator___cmp__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    bool  _result;
    HistoryIterator * _arg0;
    HistoryIterator * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:HistoryIterator___cmp__",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryIterator___cmp__. Expected _HistoryIterator_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_HistoryIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of HistoryIterator___cmp__. Expected _HistoryIterator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (bool )HistoryIterator___cmp__(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static String  HistoryIterator___str__(HistoryIterator *self) {
        return DateFormatter::toString((*self)->date()) + 
        "\t" + (IsNull((*self)->value()) ? String("Null") : 
        DoubleFormatter::toString((*self)->value()));
    }
static PyObject *_wrap_HistoryIterator___str__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    HistoryIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:HistoryIterator___str__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryIterator___str__. Expected _HistoryIterator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (HistoryIterator___str__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

#define delete_HistoryValidIterator(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_HistoryValidIterator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryValidIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_HistoryValidIterator",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryValidIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_HistoryValidIterator. Expected _HistoryValidIterator_p.");
        return NULL;
        }
    }
{
	try {
		    delete_HistoryValidIterator(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static Date  HistoryValidIterator_date(HistoryValidIterator *self) {
        return (*self)->date();
    }
static PyObject *_wrap_HistoryValidIterator_date(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    HistoryValidIterator * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:HistoryValidIterator_date",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryValidIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryValidIterator_date. Expected _HistoryValidIterator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (HistoryValidIterator_date(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static double  HistoryValidIterator_value(HistoryValidIterator *self) {
        return (*self)->value();
    }
static PyObject *_wrap_HistoryValidIterator_value(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    HistoryValidIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:HistoryValidIterator_value",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryValidIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryValidIterator_value. Expected _HistoryValidIterator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )HistoryValidIterator_value(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static void  HistoryValidIterator_advance(HistoryValidIterator *self) {
        (*self)++;
    }
static PyObject *_wrap_HistoryValidIterator_advance(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryValidIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:HistoryValidIterator_advance",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryValidIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryValidIterator_advance. Expected _HistoryValidIterator_p.");
        return NULL;
        }
    }
{
	try {
		    HistoryValidIterator_advance(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static bool  HistoryValidIterator___cmp__(HistoryValidIterator *self,const HistoryValidIterator & other) {
        return (*self == other ? 0 : -1);
    }
static PyObject *_wrap_HistoryValidIterator___cmp__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    bool  _result;
    HistoryValidIterator * _arg0;
    HistoryValidIterator * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:HistoryValidIterator___cmp__",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryValidIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryValidIterator___cmp__. Expected _HistoryValidIterator_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_HistoryValidIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of HistoryValidIterator___cmp__. Expected _HistoryValidIterator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (bool )HistoryValidIterator___cmp__(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static String  HistoryValidIterator___str__(HistoryValidIterator *self) {
        return DateFormatter::toString((*self)->date()) + 
        "\t" + (IsNull((*self)->value()) ? String("Null") : 
        DoubleFormatter::toString((*self)->value()));
    }
static PyObject *_wrap_HistoryValidIterator___str__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    HistoryValidIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:HistoryValidIterator___str__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryValidIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryValidIterator___str__. Expected _HistoryValidIterator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (HistoryValidIterator___str__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

#define delete_HistoryDataIterator(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_HistoryDataIterator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryDataIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_HistoryDataIterator",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryDataIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_HistoryDataIterator. Expected _HistoryDataIterator_p.");
        return NULL;
        }
    }
{
	try {
		    delete_HistoryDataIterator(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static double  HistoryDataIterator___float__(HistoryDataIterator *self) {
        return **self;
    }
static PyObject *_wrap_HistoryDataIterator___float__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    HistoryDataIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:HistoryDataIterator___float__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryDataIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryDataIterator___float__. Expected _HistoryDataIterator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )HistoryDataIterator___float__(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static void  HistoryDataIterator_advance(HistoryDataIterator *self) {
        (*self)++;
    }
static PyObject *_wrap_HistoryDataIterator_advance(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryDataIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:HistoryDataIterator_advance",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryDataIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryDataIterator_advance. Expected _HistoryDataIterator_p.");
        return NULL;
        }
    }
{
	try {
		    HistoryDataIterator_advance(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static bool  HistoryDataIterator___cmp__(HistoryDataIterator *self,const HistoryDataIterator & other) {
        return (*self == other ? 0 : -1);
    }
static PyObject *_wrap_HistoryDataIterator___cmp__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    bool  _result;
    HistoryDataIterator * _arg0;
    HistoryDataIterator * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:HistoryDataIterator___cmp__",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryDataIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryDataIterator___cmp__. Expected _HistoryDataIterator_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_HistoryDataIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of HistoryDataIterator___cmp__. Expected _HistoryDataIterator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (bool )HistoryDataIterator___cmp__(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static String  HistoryDataIterator___str__(HistoryDataIterator *self) {
        return (IsNull(**self) ? String("Null") : 
        DoubleFormatter::toString(**self));
    }
static PyObject *_wrap_HistoryDataIterator___str__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    HistoryDataIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:HistoryDataIterator___str__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryDataIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryDataIterator___str__. Expected _HistoryDataIterator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (HistoryDataIterator___str__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

#define delete_HistoryValidDataIterator(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_HistoryValidDataIterator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryValidDataIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_HistoryValidDataIterator",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryValidDataIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_HistoryValidDataIterator. Expected _HistoryValidDataIterator_p.");
        return NULL;
        }
    }
{
	try {
		    delete_HistoryValidDataIterator(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static double  HistoryValidDataIterator___float__(HistoryValidDataIterator *self) {
        return **self;
    }
static PyObject *_wrap_HistoryValidDataIterator___float__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    HistoryValidDataIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:HistoryValidDataIterator___float__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryValidDataIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryValidDataIterator___float__. Expected _HistoryValidDataIterator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )HistoryValidDataIterator___float__(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static void  HistoryValidDataIterator_advance(HistoryValidDataIterator *self) {
        (*self)++;
    }
static PyObject *_wrap_HistoryValidDataIterator_advance(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryValidDataIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:HistoryValidDataIterator_advance",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryValidDataIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryValidDataIterator_advance. Expected _HistoryValidDataIterator_p.");
        return NULL;
        }
    }
{
	try {
		    HistoryValidDataIterator_advance(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static bool  HistoryValidDataIterator___cmp__(HistoryValidDataIterator *self,const HistoryValidDataIterator & other) {
        return (*self == other ? 0 : -1);
    }
static PyObject *_wrap_HistoryValidDataIterator___cmp__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    bool  _result;
    HistoryValidDataIterator * _arg0;
    HistoryValidDataIterator * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:HistoryValidDataIterator___cmp__",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryValidDataIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryValidDataIterator___cmp__. Expected _HistoryValidDataIterator_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_HistoryValidDataIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of HistoryValidDataIterator___cmp__. Expected _HistoryValidDataIterator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (bool )HistoryValidDataIterator___cmp__(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static String  HistoryValidDataIterator___str__(HistoryValidDataIterator *self) {
        return (IsNull(**self) ? String("Null") : 
        DoubleFormatter::toString(**self));
    }
static PyObject *_wrap_HistoryValidDataIterator___str__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    HistoryValidDataIterator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:HistoryValidDataIterator___str__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_HistoryValidDataIterator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of HistoryValidDataIterator___str__. Expected _HistoryValidDataIterator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (HistoryValidDataIterator___str__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

#define new_History(_swigarg0,_swigarg1) (new History(_swigarg0,_swigarg1))
static PyObject *_wrap_new_History(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    History * _result;
    DateVector * _arg0;
    DoubleVector * _arg1;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"OO:new_History",&_obj0,&_obj1)) 
        return NULL;
{
	if (PyTuple_Check(_obj0)) {
		int size = PyTuple_Size(_obj0);
		_arg0 = new std::vector<Date>(size);
		for (int i=0; i<size; i++) {
			Date* d;
			PyObject* o = PyTuple_GetItem(_obj0,i);
			if ((SWIG_ConvertPtr(o,(void **) &d,
			  (swig_type_info *)SWIG_TypeQuery("Date *"),1)) != -1) {
				(*_arg0)[i] = *d;
			} else {
				PyErr_SetString(PyExc_TypeError,"tuple must contain dates");
				delete _arg0;
				return NULL;
			}
		}
	} else if (PyList_Check(_obj0)) {
		int size = PyList_Size(_obj0);
		_arg0 = new std::vector<Date>(size);
		for (int i=0; i<size; i++) {
			Date* d;
			PyObject* o = PyList_GetItem(_obj0,i);
			if ((SWIG_ConvertPtr(o,(void **) &d,
			  (swig_type_info *)SWIG_TypeQuery("Date *"),1)) != -1) {
				(*_arg0)[i] = *d;
			} else {
				PyErr_SetString(PyExc_TypeError,"list must contain dates");
				delete _arg0;
				return NULL;
			}
		}
	} else {
		PyErr_SetString(PyExc_TypeError,"not a sequence");
		return NULL;
	}
}
{
    if (PyTuple_Check(_obj1)) {
        int size = PyTuple_Size(_obj1);
        _arg1 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj1)) {
        int size = PyList_Size(_obj1);
        _arg1 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
	try {
		    _result = (History *)new_History(*_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_History_p");
    _resultobj = Py_BuildValue("s",_ptemp);
{
	delete _arg0;
}
{
    delete _arg1;
}
    return _resultobj;
}

#define delete_History(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_History(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    History * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_History",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_History. Expected _History_p.");
        return NULL;
        }
    }
{
	try {
		    delete_History(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define History_firstDate(_swigobj)  (_swigobj->firstDate())
static PyObject *_wrap_History_firstDate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    History * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:History_firstDate",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_firstDate. Expected _History_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (History_firstDate(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define History_lastDate(_swigobj)  (_swigobj->lastDate())
static PyObject *_wrap_History_lastDate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    History * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:History_lastDate",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_lastDate. Expected _History_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (History_lastDate(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define History_size(_swigobj)  (_swigobj->size())
static PyObject *_wrap_History_size(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    History * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:History_size",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_size. Expected _History_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )History_size(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define History_begin(_swigobj)  (_swigobj->begin())
static PyObject *_wrap_History_begin(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryIterator * _result;
    History * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:History_begin",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_begin. Expected _History_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new HistoryIterator (History_begin(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_HistoryIterator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define History_end(_swigobj)  (_swigobj->end())
static PyObject *_wrap_History_end(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryIterator * _result;
    History * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:History_end",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_end. Expected _History_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new HistoryIterator (History_end(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_HistoryIterator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define History_iterator(_swigobj,_swigarg0)  (_swigobj->iterator(_swigarg0))
static PyObject *_wrap_History_iterator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryIterator * _result;
    History * _arg0;
    Date * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"ss:History_iterator",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_iterator. Expected _History_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of History_iterator. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new HistoryIterator (History_iterator(_arg0,*_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_HistoryIterator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define History_vbegin(_swigobj)  (_swigobj->vbegin())
static PyObject *_wrap_History_vbegin(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryValidIterator * _result;
    History * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:History_vbegin",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_vbegin. Expected _History_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new HistoryValidIterator (History_vbegin(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_HistoryValidIterator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define History_vend(_swigobj)  (_swigobj->vend())
static PyObject *_wrap_History_vend(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryValidIterator * _result;
    History * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:History_vend",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_vend. Expected _History_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new HistoryValidIterator (History_vend(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_HistoryValidIterator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define History_valid_iterator(_swigobj,_swigarg0)  (_swigobj->valid_iterator(_swigarg0))
static PyObject *_wrap_History_valid_iterator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryValidIterator * _result;
    History * _arg0;
    Date * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"ss:History_valid_iterator",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_valid_iterator. Expected _History_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of History_valid_iterator. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new HistoryValidIterator (History_valid_iterator(_arg0,*_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_HistoryValidIterator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define History_dbegin(_swigobj)  (_swigobj->dbegin())
static PyObject *_wrap_History_dbegin(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryDataIterator * _result;
    History * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:History_dbegin",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_dbegin. Expected _History_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new HistoryDataIterator (History_dbegin(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_HistoryDataIterator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define History_dend(_swigobj)  (_swigobj->dend())
static PyObject *_wrap_History_dend(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryDataIterator * _result;
    History * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:History_dend",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_dend. Expected _History_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new HistoryDataIterator (History_dend(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_HistoryDataIterator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define History_data_iterator(_swigobj,_swigarg0)  (_swigobj->data_iterator(_swigarg0))
static PyObject *_wrap_History_data_iterator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryDataIterator * _result;
    History * _arg0;
    Date * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"ss:History_data_iterator",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_data_iterator. Expected _History_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of History_data_iterator. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new HistoryDataIterator (History_data_iterator(_arg0,*_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_HistoryDataIterator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define History_vdbegin(_swigobj)  (_swigobj->vdbegin())
static PyObject *_wrap_History_vdbegin(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryValidDataIterator * _result;
    History * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:History_vdbegin",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_vdbegin. Expected _History_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new HistoryValidDataIterator (History_vdbegin(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_HistoryValidDataIterator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define History_vdend(_swigobj)  (_swigobj->vdend())
static PyObject *_wrap_History_vdend(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryValidDataIterator * _result;
    History * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:History_vdend",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_vdend. Expected _History_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new HistoryValidDataIterator (History_vdend(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_HistoryValidDataIterator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define History_valid_data_iterator(_swigobj,_swigarg0)  (_swigobj->valid_data_iterator(_swigarg0))
static PyObject *_wrap_History_valid_data_iterator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    HistoryValidDataIterator * _result;
    History * _arg0;
    Date * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"ss:History_valid_data_iterator",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History_valid_data_iterator. Expected _History_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of History_valid_data_iterator. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new HistoryValidDataIterator (History_valid_data_iterator(_arg0,*_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_HistoryValidDataIterator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static double  History___getitem__(History *self,Date  d) {
        return (*self)[d];
    }
static PyObject *_wrap_History___getitem__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    History * _arg0;
    Date * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:History___getitem__",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History___getitem__. Expected _History_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of History___getitem__. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )History___getitem__(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static String  History___str__(History *self) {
        return "Historical data from " + 
            DateFormatter::toString(self->firstDate()) +
            " to " + DateFormatter::toString(self->lastDate());
    }
static PyObject *_wrap_History___str__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    History * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:History___str__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History___str__. Expected _History_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (History___str__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

static String  History___repr__(History *self) {
        return "<History: historical data from " + 
            DateFormatter::toString(self->firstDate()) + 
            " to " + DateFormatter::toString(self->lastDate())+">";
    }
static PyObject *_wrap_History___repr__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    History * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:History___repr__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_History_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of History___repr__. Expected _History_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (History___repr__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

#define delete_TermStructureHandle(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_TermStructure(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TermStructureHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_TermStructure",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_TermStructure. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
{
	try {
		    delete_TermStructureHandle(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static TermStructureHandle  TermStructureHandle_clone(TermStructureHandle *self) {
		return (*self)->clone();
	}
static PyObject *_wrap_TermStructure_clone(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TermStructureHandle * _result;
    TermStructureHandle * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:TermStructure_clone",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TermStructure_clone. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new TermStructureHandle (TermStructureHandle_clone(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_TermStructureHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static CurrencyHandle  TermStructureHandle_currency(TermStructureHandle *self) {
		return (*self)->currency();
	}
static PyObject *_wrap_TermStructure_currency(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CurrencyHandle * _result;
    TermStructureHandle * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:TermStructure_currency",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TermStructure_currency. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new CurrencyHandle (TermStructureHandle_currency(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CurrencyHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static Date  TermStructureHandle_todaysDate(TermStructureHandle *self) {
		return (*self)->todaysDate();
	}
static PyObject *_wrap_TermStructure_todaysDate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    TermStructureHandle * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:TermStructure_todaysDate",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TermStructure_todaysDate. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (TermStructureHandle_todaysDate(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static Date  TermStructureHandle_settlementDate(TermStructureHandle *self) {
		return (*self)->settlementDate();
	}
static PyObject *_wrap_TermStructure_settlementDate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    TermStructureHandle * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:TermStructure_settlementDate",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TermStructure_settlementDate. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (TermStructureHandle_settlementDate(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static CalendarHandle  TermStructureHandle_calendar(TermStructureHandle *self) {
		return (*self)->calendar();
	}
static PyObject *_wrap_TermStructure_calendar(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    CalendarHandle * _result;
    TermStructureHandle * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:TermStructure_calendar",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TermStructure_calendar. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new CalendarHandle (TermStructureHandle_calendar(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_CalendarHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static Date  TermStructureHandle_maxDate(TermStructureHandle *self) {
		return (*self)->maxDate();
	}
static PyObject *_wrap_TermStructure_maxDate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    TermStructureHandle * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:TermStructure_maxDate",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TermStructure_maxDate. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (TermStructureHandle_maxDate(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static Date  TermStructureHandle_minDate(TermStructureHandle *self) {
		return (*self)->minDate();
	}
static PyObject *_wrap_TermStructure_minDate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    TermStructureHandle * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:TermStructure_minDate",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TermStructure_minDate. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (TermStructureHandle_minDate(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static Rate  TermStructureHandle_zeroYield(TermStructureHandle *self,const Date & d) {
		return (*self)->zeroYield(d);
	}
static PyObject *_wrap_TermStructure_zeroYield(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Rate  _result;
    TermStructureHandle * _arg0;
    Date * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:TermStructure_zeroYield",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TermStructure_zeroYield. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of TermStructure_zeroYield. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (Rate )TermStructureHandle_zeroYield(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static DiscountFactor  TermStructureHandle_discount(TermStructureHandle *self,const Date & d) {
		return (*self)->discount(d);
	}
static PyObject *_wrap_TermStructure_discount(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DiscountFactor  _result;
    TermStructureHandle * _arg0;
    Date * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:TermStructure_discount",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TermStructure_discount. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of TermStructure_discount. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (DiscountFactor )TermStructureHandle_discount(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static Rate  TermStructureHandle_forward(TermStructureHandle *self,const Date & d) {
		return (*self)->forward(d);
	}
static PyObject *_wrap_TermStructure_forward(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Rate  _result;
    TermStructureHandle * _arg0;
    Date * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:TermStructure_forward",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TermStructure_forward. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of TermStructure_forward. Expected _Date_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (Rate )TermStructureHandle_forward(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static int  TermStructureHandle___nonzero__(TermStructureHandle *self) {
		return (IsNull(*self) ? 0 : 1);
	}
static PyObject *_wrap_TermStructure___nonzero__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    TermStructureHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:TermStructure___nonzero__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TermStructure___nonzero__. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )TermStructureHandle___nonzero__(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define new_Deposit(_swigarg0,_swigarg1,_swigarg2) (new Deposit(_swigarg0,_swigarg1,_swigarg2))
static PyObject *_wrap_new_Deposit(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Deposit * _result;
    Date * _arg0;
    Rate  _arg1;
    DayCounterHandle * _arg2;
    char * _argc0 = 0;
    char * _argc2 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"sds:new_Deposit",&_argc0,&_arg1,&_argc2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Date_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of new_Deposit. Expected _Date_p.");
        return NULL;
        }
    }
    if (_argc2) {
        if (SWIG_GetPtr(_argc2,(void **) &_arg2,"_DayCounterHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 3 of new_Deposit. Expected _DayCounterHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (Deposit *)new_Deposit(*_arg0,_arg1,*_arg2);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_Deposit_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_Deposit(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_Deposit(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Deposit * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_Deposit",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Deposit_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_Deposit. Expected _Deposit_p.");
        return NULL;
        }
    }
{
	try {
		    delete_Deposit(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define Deposit_maturity(_swigobj)  (_swigobj->maturity())
static PyObject *_wrap_Deposit_maturity(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Date * _result;
    Deposit * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:Deposit_maturity",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Deposit_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Deposit_maturity. Expected _Deposit_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new Date (Deposit_maturity(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_Date_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define Deposit_rate(_swigobj)  (_swigobj->rate())
static PyObject *_wrap_Deposit_rate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Rate  _result;
    Deposit * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Deposit_rate",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Deposit_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Deposit_rate. Expected _Deposit_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (Rate )Deposit_rate(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define Deposit_dayCounter(_swigobj)  (_swigobj->dayCounter())
static PyObject *_wrap_Deposit_dayCounter(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DayCounterHandle * _result;
    Deposit * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:Deposit_dayCounter",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Deposit_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Deposit_dayCounter. Expected _Deposit_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new DayCounterHandle (Deposit_dayCounter(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_DayCounterHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_InstrumentHandle(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_Instrument(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    InstrumentHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_Instrument",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InstrumentHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_Instrument. Expected _InstrumentHandle_p.");
        return NULL;
        }
    }
{
	try {
		    delete_InstrumentHandle(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  InstrumentHandle_setPrice(InstrumentHandle *self,double  price) {
		(*self)->setPrice(price);
	}
static PyObject *_wrap_Instrument_setPrice(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    InstrumentHandle * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:Instrument_setPrice",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InstrumentHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Instrument_setPrice. Expected _InstrumentHandle_p.");
        return NULL;
        }
    }
{
	try {
		    InstrumentHandle_setPrice(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  InstrumentHandle_setTermStructure(InstrumentHandle *self,TermStructureHandle  h) {
		(*self)->setTermStructure(h);
	}
static PyObject *_wrap_Instrument_setTermStructure(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    InstrumentHandle * _arg0;
    TermStructureHandle * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:Instrument_setTermStructure",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InstrumentHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Instrument_setTermStructure. Expected _InstrumentHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_TermStructureHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of Instrument_setTermStructure. Expected _TermStructureHandle_p.");
        return NULL;
        }
    }
{
	try {
		    InstrumentHandle_setTermStructure(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static String  InstrumentHandle_isinCode(InstrumentHandle *self) {
		return (*self)->isinCode();
	}
static PyObject *_wrap_Instrument_isinCode(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    InstrumentHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Instrument_isinCode",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InstrumentHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Instrument_isinCode. Expected _InstrumentHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (InstrumentHandle_isinCode(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

static String  InstrumentHandle_description(InstrumentHandle *self) {
		return (*self)->description();
	}
static PyObject *_wrap_Instrument_description(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    InstrumentHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Instrument_description",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InstrumentHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Instrument_description. Expected _InstrumentHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (InstrumentHandle_description(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

static TermStructureHandle  InstrumentHandle_termStructure(InstrumentHandle *self) {
		return (*self)->termStructure();
	}
static PyObject *_wrap_Instrument_termStructure(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TermStructureHandle * _result;
    InstrumentHandle * _arg0;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"s:Instrument_termStructure",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InstrumentHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Instrument_termStructure. Expected _InstrumentHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new TermStructureHandle (InstrumentHandle_termStructure(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (void *) _result,"_TermStructureHandle_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

static double  InstrumentHandle_NPV(InstrumentHandle *self) {
		return (*self)->NPV();
	}
static PyObject *_wrap_Instrument_NPV(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    InstrumentHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Instrument_NPV",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InstrumentHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Instrument_NPV. Expected _InstrumentHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )InstrumentHandle_NPV(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  InstrumentHandle_price(InstrumentHandle *self) {
		return (*self)->price();
	}
static PyObject *_wrap_Instrument_price(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    InstrumentHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Instrument_price",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InstrumentHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Instrument_price. Expected _InstrumentHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )InstrumentHandle_price(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static String  InstrumentHandle___str__(InstrumentHandle *self) {
		return Representation(*self);
	}
static PyObject *_wrap_Instrument___str__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    InstrumentHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Instrument___str__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InstrumentHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Instrument___str__. Expected _InstrumentHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (InstrumentHandle___str__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

static String  InstrumentHandle___repr__(InstrumentHandle *self) {
		return "<Handle<Instrument>: "+Representation(*self)+">";
	}
static PyObject *_wrap_Instrument___repr__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    String * _result;
    InstrumentHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Instrument___repr__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InstrumentHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Instrument___repr__. Expected _InstrumentHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new String (InstrumentHandle___repr__(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
	_resultobj = PyString_FromString(_result->c_str());
}
{
	delete _result;
}
    return _resultobj;
}

static int  InstrumentHandle___cmp__(InstrumentHandle *self,const InstrumentHandle & other) {
		return ((*self) == other ? 0 : 1);
	}
static PyObject *_wrap_Instrument___cmp__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    InstrumentHandle * _arg0;
    InstrumentHandle * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:Instrument___cmp__",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InstrumentHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Instrument___cmp__. Expected _InstrumentHandle_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_InstrumentHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of Instrument___cmp__. Expected _InstrumentHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )InstrumentHandle___cmp__(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

static int  InstrumentHandle___nonzero__(InstrumentHandle *self) {
		return (IsNull(*self) ? 0 : 1);
	}
static PyObject *_wrap_Instrument___nonzero__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    InstrumentHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Instrument___nonzero__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InstrumentHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Instrument___nonzero__. Expected _InstrumentHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )InstrumentHandle___nonzero__(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define delete_InterpolationHandle(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_Interpolation(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    InterpolationHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_Interpolation",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InterpolationHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_Interpolation. Expected _InterpolationHandle_p.");
        return NULL;
        }
    }
{
	try {
		    delete_InterpolationHandle(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static double  InterpolationHandle___call__(InterpolationHandle *self,double  x) {
		return (**self)(x);
	}
static PyObject *_wrap_Interpolation___call__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    InterpolationHandle * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:Interpolation___call__",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InterpolationHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Interpolation___call__. Expected _InterpolationHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )InterpolationHandle___call__(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static int  InterpolationHandle___nonzero__(InterpolationHandle *self) {
		return (IsNull(*self) ? 0 : 1);
	}
static PyObject *_wrap_Interpolation___nonzero__(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    InterpolationHandle * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Interpolation___nonzero__",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_InterpolationHandle_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Interpolation___nonzero__. Expected _InterpolationHandle_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )InterpolationHandle___nonzero__(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define new_StandardPathGenerator(_swigarg0,_swigarg1) (new StandardPathGenerator(_swigarg0,_swigarg1))
static PyObject *_wrap_new_StandardPathGenerator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    StandardPathGenerator * _result;
    int  _arg0;
    long  _arg1 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"i|l:new_StandardPathGenerator",&_arg0,&_arg1)) 
        return NULL;
{
	try {
		    _result = (StandardPathGenerator *)new_StandardPathGenerator(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_StandardPathGenerator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define StandardPathGenerator_next(_swigobj)  (_swigobj->next())
static PyObject *_wrap_StandardPathGenerator_next(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PyArray * _result;
    StandardPathGenerator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:StandardPathGenerator_next",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_StandardPathGenerator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of StandardPathGenerator_next. Expected _StandardPathGenerator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = new PyArray (StandardPathGenerator_next(_arg0));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
    _resultobj = PyTuple_New(_result->size());
    for (int i=0; i<_result->size(); i++)
        PyTuple_SetItem(_resultobj,i,PyFloat_FromDouble((*_result)[i]));
}
{
    delete _result;
}
    return _resultobj;
}

#define StandardPathGenerator_weight(_swigobj)  (_swigobj->weight())
static PyObject *_wrap_StandardPathGenerator_weight(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    StandardPathGenerator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:StandardPathGenerator_weight",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_StandardPathGenerator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of StandardPathGenerator_weight. Expected _StandardPathGenerator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )StandardPathGenerator_weight(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define new_McEuropeanPricer(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4,_swigarg5,_swigarg6,_swigarg7,_swigarg8,_swigarg9) (new McEuropeanPricer(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4,_swigarg5,_swigarg6,_swigarg7,_swigarg8,_swigarg9))
static PyObject *_wrap_new_McEuropeanPricer(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    McEuropeanPricer * _result;
    OptionType * _arg0;
    double  _arg1;
    double  _arg2;
    Rate  _arg3;
    Rate  _arg4;
    double  _arg5;
    double  _arg6;
    int  _arg7;
    int  _arg8;
    long  _arg9;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"sddddddiil:new_McEuropeanPricer",&_argc0,&_arg1,&_arg2,&_arg3,&_arg4,&_arg5,&_arg6,&_arg7,&_arg8,&_arg9)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_OptionType_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of new_McEuropeanPricer. Expected _OptionType_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (McEuropeanPricer *)new_McEuropeanPricer(*_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_McEuropeanPricer_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define McEuropeanPricer_value(_swigobj)  (_swigobj->value())
static PyObject *_wrap_McEuropeanPricer_value(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    McEuropeanPricer * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:McEuropeanPricer_value",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_McEuropeanPricer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of McEuropeanPricer_value. Expected _McEuropeanPricer_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )McEuropeanPricer_value(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define McEuropeanPricer_errorEstimate(_swigobj)  (_swigobj->errorEstimate())
static PyObject *_wrap_McEuropeanPricer_errorEstimate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    McEuropeanPricer * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:McEuropeanPricer_errorEstimate",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_McEuropeanPricer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of McEuropeanPricer_errorEstimate. Expected _McEuropeanPricer_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )McEuropeanPricer_errorEstimate(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define new_GeometricAsianOption(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4,_swigarg5,_swigarg6) (new GeometricAsianOption(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4,_swigarg5,_swigarg6))
static PyObject *_wrap_new_GeometricAsianOption(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    GeometricAsianOption * _result;
    OptionType * _arg0;
    double  _arg1;
    double  _arg2;
    Rate  _arg3;
    Rate  _arg4;
    double  _arg5;
    double  _arg6;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"sdddddd:new_GeometricAsianOption",&_argc0,&_arg1,&_arg2,&_arg3,&_arg4,&_arg5,&_arg6)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_OptionType_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of new_GeometricAsianOption. Expected _OptionType_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (GeometricAsianOption *)new_GeometricAsianOption(*_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_GeometricAsianOption_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define GeometricAsianOption_value(_swigobj)  (_swigobj->value())
static PyObject *_wrap_GeometricAsianOption_value(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    GeometricAsianOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:GeometricAsianOption_value",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_GeometricAsianOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of GeometricAsianOption_value. Expected _GeometricAsianOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )GeometricAsianOption_value(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define new_McAsianPricer(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4,_swigarg5,_swigarg6,_swigarg7,_swigarg8,_swigarg9) (new McAsianPricer(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4,_swigarg5,_swigarg6,_swigarg7,_swigarg8,_swigarg9))
static PyObject *_wrap_new_McAsianPricer(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    McAsianPricer * _result;
    OptionType * _arg0;
    double  _arg1;
    double  _arg2;
    Rate  _arg3;
    Rate  _arg4;
    double  _arg5;
    double  _arg6;
    int  _arg7;
    int  _arg8;
    long  _arg9;
    char * _argc0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"sddddddiil:new_McAsianPricer",&_argc0,&_arg1,&_arg2,&_arg3,&_arg4,&_arg5,&_arg6,&_arg7,&_arg8,&_arg9)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_OptionType_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of new_McAsianPricer. Expected _OptionType_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (McAsianPricer *)new_McAsianPricer(*_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_McAsianPricer_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define McAsianPricer_value(_swigobj)  (_swigobj->value())
static PyObject *_wrap_McAsianPricer_value(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    McAsianPricer * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:McAsianPricer_value",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_McAsianPricer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of McAsianPricer_value. Expected _McAsianPricer_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )McAsianPricer_value(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define McAsianPricer_errorEstimate(_swigobj)  (_swigobj->errorEstimate())
static PyObject *_wrap_McAsianPricer_errorEstimate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    McAsianPricer * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:McAsianPricer_errorEstimate",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_McAsianPricer_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of McAsianPricer_errorEstimate. Expected _McAsianPricer_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )McAsianPricer_errorEstimate(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define new_TridiagonalOperator(_swigarg0,_swigarg1,_swigarg2) (new TridiagonalOperator(_swigarg0,_swigarg1,_swigarg2))
static PyObject *_wrap_new_TridiagonalOperator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TridiagonalOperator * _result;
    PyArray * _arg0;
    PyArray * _arg1;
    PyArray * _arg2;
    PyObject * _obj0 = 0;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"OOO:new_TridiagonalOperator",&_obj0,&_obj1,&_obj2)) 
        return NULL;
{
    if (PyTuple_Check(_obj0)) {
        int size = PyTuple_Size(_obj0);
        _arg0 = new PyArray (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj0,i);
            if (PyFloat_Check(o)) {
                (*_arg0)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg0)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg0)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg0;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj0)) {
        int size = PyList_Size(_obj0);
        _arg0 = new PyArray (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj0,i);
            if (PyFloat_Check(o)) {
                (*_arg0)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg0)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg0)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg0;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
    if (PyTuple_Check(_obj1)) {
        int size = PyTuple_Size(_obj1);
        _arg1 = new PyArray (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj1)) {
        int size = PyList_Size(_obj1);
        _arg1 = new PyArray (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
    if (PyTuple_Check(_obj2)) {
        int size = PyTuple_Size(_obj2);
        _arg2 = new PyArray (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj2,i);
            if (PyFloat_Check(o)) {
                (*_arg2)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg2)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg2)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg2;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj2)) {
        int size = PyList_Size(_obj2);
        _arg2 = new PyArray (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj2,i);
            if (PyFloat_Check(o)) {
                (*_arg2)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg2)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg2)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg2;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
	try {
		    _result = (TridiagonalOperator *)new_TridiagonalOperator(*_arg0,*_arg1,*_arg2);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_TridiagonalOperator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
{
    delete _arg0;
}
{
    delete _arg1;
}
{
    delete _arg2;
}
    return _resultobj;
}

#define delete_TridiagonalOperator(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_TridiagonalOperator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TridiagonalOperator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_TridiagonalOperator",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TridiagonalOperator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_TridiagonalOperator. Expected _TridiagonalOperator_p.");
        return NULL;
        }
    }
{
	try {
		    delete_TridiagonalOperator(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define TridiagonalOperator_solveFor(_swigobj,_swigarg0)  (_swigobj->solveFor(_swigarg0))
static PyObject *_wrap_TridiagonalOperator_solveFor(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PyArray * _result;
    TridiagonalOperator * _arg0;
    PyArray * _arg1;
    char * _argc0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sO:TridiagonalOperator_solveFor",&_argc0,&_obj1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TridiagonalOperator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TridiagonalOperator_solveFor. Expected _TridiagonalOperator_p.");
        return NULL;
        }
    }
{
    if (PyTuple_Check(_obj1)) {
        int size = PyTuple_Size(_obj1);
        _arg1 = new PyArray (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj1)) {
        int size = PyList_Size(_obj1);
        _arg1 = new PyArray (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
	try {
		    _result = new PyArray (TridiagonalOperator_solveFor(_arg0,*_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
    _resultobj = PyTuple_New(_result->size());
    for (int i=0; i<_result->size(); i++)
        PyTuple_SetItem(_resultobj,i,PyFloat_FromDouble((*_result)[i]));
}
{
    delete _arg1;
}
{
    delete _result;
}
    return _resultobj;
}

#define TridiagonalOperator_applyTo(_swigobj,_swigarg0)  (_swigobj->applyTo(_swigarg0))
static PyObject *_wrap_TridiagonalOperator_applyTo(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    PyArray * _result;
    TridiagonalOperator * _arg0;
    PyArray * _arg1;
    char * _argc0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sO:TridiagonalOperator_applyTo",&_argc0,&_obj1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TridiagonalOperator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TridiagonalOperator_applyTo. Expected _TridiagonalOperator_p.");
        return NULL;
        }
    }
{
    if (PyTuple_Check(_obj1)) {
        int size = PyTuple_Size(_obj1);
        _arg1 = new PyArray (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj1)) {
        int size = PyList_Size(_obj1);
        _arg1 = new PyArray (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
	try {
		    _result = new PyArray (TridiagonalOperator_applyTo(_arg0,*_arg1));

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}{
    _resultobj = PyTuple_New(_result->size());
    for (int i=0; i<_result->size(); i++)
        PyTuple_SetItem(_resultobj,i,PyFloat_FromDouble((*_result)[i]));
}
{
    delete _arg1;
}
{
    delete _result;
}
    return _resultobj;
}

#define TridiagonalOperator_size(_swigobj)  (_swigobj->size())
static PyObject *_wrap_TridiagonalOperator_size(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    TridiagonalOperator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:TridiagonalOperator_size",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TridiagonalOperator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TridiagonalOperator_size. Expected _TridiagonalOperator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )TridiagonalOperator_size(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define TridiagonalOperator_setLowerBC(_swigobj,_swigarg0)  (_swigobj->setLowerBC(_swigarg0))
static PyObject *_wrap_TridiagonalOperator_setLowerBC(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TridiagonalOperator * _arg0;
    BoundaryCondition * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:TridiagonalOperator_setLowerBC",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TridiagonalOperator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TridiagonalOperator_setLowerBC. Expected _TridiagonalOperator_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_BoundaryCondition_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of TridiagonalOperator_setLowerBC. Expected _BoundaryCondition_p.");
        return NULL;
        }
    }
{
	try {
		    TridiagonalOperator_setLowerBC(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define TridiagonalOperator_setHigherBC(_swigobj,_swigarg0)  (_swigobj->setHigherBC(_swigarg0))
static PyObject *_wrap_TridiagonalOperator_setHigherBC(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TridiagonalOperator * _arg0;
    BoundaryCondition * _arg1;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ss:TridiagonalOperator_setHigherBC",&_argc0,&_argc1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TridiagonalOperator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TridiagonalOperator_setHigherBC. Expected _TridiagonalOperator_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_BoundaryCondition_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of TridiagonalOperator_setHigherBC. Expected _BoundaryCondition_p.");
        return NULL;
        }
    }
{
	try {
		    TridiagonalOperator_setHigherBC(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define TridiagonalOperator_setFirstRow(_swigobj,_swigarg0,_swigarg1)  (_swigobj->setFirstRow(_swigarg0,_swigarg1))
static PyObject *_wrap_TridiagonalOperator_setFirstRow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TridiagonalOperator * _arg0;
    double  _arg1;
    double  _arg2;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sdd:TridiagonalOperator_setFirstRow",&_argc0,&_arg1,&_arg2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TridiagonalOperator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TridiagonalOperator_setFirstRow. Expected _TridiagonalOperator_p.");
        return NULL;
        }
    }
{
	try {
		    TridiagonalOperator_setFirstRow(_arg0,_arg1,_arg2);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define TridiagonalOperator_setMidRow(_swigobj,_swigarg0,_swigarg1,_swigarg2,_swigarg3)  (_swigobj->setMidRow(_swigarg0,_swigarg1,_swigarg2,_swigarg3))
static PyObject *_wrap_TridiagonalOperator_setMidRow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TridiagonalOperator * _arg0;
    int  _arg1;
    double  _arg2;
    double  _arg3;
    double  _arg4;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"siddd:TridiagonalOperator_setMidRow",&_argc0,&_arg1,&_arg2,&_arg3,&_arg4)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TridiagonalOperator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TridiagonalOperator_setMidRow. Expected _TridiagonalOperator_p.");
        return NULL;
        }
    }
{
	try {
		    TridiagonalOperator_setMidRow(_arg0,_arg1,_arg2,_arg3,_arg4);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define TridiagonalOperator_setMidRows(_swigobj,_swigarg0,_swigarg1,_swigarg2)  (_swigobj->setMidRows(_swigarg0,_swigarg1,_swigarg2))
static PyObject *_wrap_TridiagonalOperator_setMidRows(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TridiagonalOperator * _arg0;
    double  _arg1;
    double  _arg2;
    double  _arg3;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sddd:TridiagonalOperator_setMidRows",&_argc0,&_arg1,&_arg2,&_arg3)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TridiagonalOperator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TridiagonalOperator_setMidRows. Expected _TridiagonalOperator_p.");
        return NULL;
        }
    }
{
	try {
		    TridiagonalOperator_setMidRows(_arg0,_arg1,_arg2,_arg3);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define TridiagonalOperator_setLastRow(_swigobj,_swigarg0,_swigarg1)  (_swigobj->setLastRow(_swigarg0,_swigarg1))
static PyObject *_wrap_TridiagonalOperator_setLastRow(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    TridiagonalOperator * _arg0;
    double  _arg1;
    double  _arg2;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sdd:TridiagonalOperator_setLastRow",&_argc0,&_arg1,&_arg2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_TridiagonalOperator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of TridiagonalOperator_setLastRow. Expected _TridiagonalOperator_p.");
        return NULL;
        }
    }
{
	try {
		    TridiagonalOperator_setLastRow(_arg0,_arg1,_arg2);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void *SwigDPlusToTridiagonalOperator(void *ptr) {
    DPlus *src;
    TridiagonalOperator *dest;
    src = (DPlus *) ptr;
    dest = (TridiagonalOperator *) src;
    return (void *) dest;
}

#define new_DPlus(_swigarg0,_swigarg1) (new DPlus(_swigarg0,_swigarg1))
static PyObject *_wrap_new_DPlus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DPlus * _result;
    int  _arg0;
    double  _arg1;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"id:new_DPlus",&_arg0,&_arg1)) 
        return NULL;
{
	try {
		    _result = (DPlus *)new_DPlus(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_DPlus_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_DPlus(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_DPlus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DPlus * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_DPlus",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DPlus_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_DPlus. Expected _DPlus_p.");
        return NULL;
        }
    }
{
	try {
		    delete_DPlus(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void *SwigDMinusToTridiagonalOperator(void *ptr) {
    DMinus *src;
    TridiagonalOperator *dest;
    src = (DMinus *) ptr;
    dest = (TridiagonalOperator *) src;
    return (void *) dest;
}

#define new_DMinus(_swigarg0,_swigarg1) (new DMinus(_swigarg0,_swigarg1))
static PyObject *_wrap_new_DMinus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DMinus * _result;
    int  _arg0;
    double  _arg1;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"id:new_DMinus",&_arg0,&_arg1)) 
        return NULL;
{
	try {
		    _result = (DMinus *)new_DMinus(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_DMinus_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_DMinus(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_DMinus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DMinus * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_DMinus",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DMinus_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_DMinus. Expected _DMinus_p.");
        return NULL;
        }
    }
{
	try {
		    delete_DMinus(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void *SwigDZeroToTridiagonalOperator(void *ptr) {
    DZero *src;
    TridiagonalOperator *dest;
    src = (DZero *) ptr;
    dest = (TridiagonalOperator *) src;
    return (void *) dest;
}

#define new_DZero(_swigarg0,_swigarg1) (new DZero(_swigarg0,_swigarg1))
static PyObject *_wrap_new_DZero(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DZero * _result;
    int  _arg0;
    double  _arg1;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"id:new_DZero",&_arg0,&_arg1)) 
        return NULL;
{
	try {
		    _result = (DZero *)new_DZero(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_DZero_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_DZero(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_DZero(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DZero * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_DZero",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DZero_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_DZero. Expected _DZero_p.");
        return NULL;
        }
    }
{
	try {
		    delete_DZero(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void *SwigDPlusDMinusToTridiagonalOperator(void *ptr) {
    DPlusDMinus *src;
    TridiagonalOperator *dest;
    src = (DPlusDMinus *) ptr;
    dest = (TridiagonalOperator *) src;
    return (void *) dest;
}

#define new_DPlusDMinus(_swigarg0,_swigarg1) (new DPlusDMinus(_swigarg0,_swigarg1))
static PyObject *_wrap_new_DPlusDMinus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DPlusDMinus * _result;
    int  _arg0;
    double  _arg1;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"id:new_DPlusDMinus",&_arg0,&_arg1)) 
        return NULL;
{
	try {
		    _result = (DPlusDMinus *)new_DPlusDMinus(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_DPlusDMinus_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_DPlusDMinus(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_DPlusDMinus(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DPlusDMinus * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_DPlusDMinus",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DPlusDMinus_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_DPlusDMinus. Expected _DPlusDMinus_p.");
        return NULL;
        }
    }
{
	try {
		    delete_DPlusDMinus(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define new_BSMEuropeanOption(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4,_swigarg5,_swigarg6) (new BSMEuropeanOption(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4,_swigarg5,_swigarg6))
static PyObject *_wrap_new_BSMEuropeanOption(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BSMEuropeanOption * _result;
    OptionType * _arg0;
    double  _arg1;
    double  _arg2;
    Rate  _arg3;
    Rate  _arg4;
    Time  _arg5;
    double  _arg6;
    PyObject * _obj0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"Odddddd:new_BSMEuropeanOption",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4,&_arg5,&_arg6)) 
        return NULL;
{
	if (PyString_Check(_obj0)) {
		_arg0 = new OptionType;
		std::string s(PyString_AsString(_obj0));
		s = StringFormatter::toLowercase(s);
		if (s == "call")				*(_arg0) = Option::Call;
		else if (s == "put")			*(_arg0) = Option::Put;
		else if (s == "straddle")		*(_arg0) = Option::Straddle;
		else {
			PyErr_SetString(PyExc_TypeError,"unknown option type");
			delete _arg0;
			return NULL;
		}
	} else {
		PyErr_SetString(PyExc_TypeError,"not an option type");
		return NULL;
	}
}
{
	try {
		    _result = (BSMEuropeanOption *)new_BSMEuropeanOption(*_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_BSMEuropeanOption_p");
    _resultobj = Py_BuildValue("s",_ptemp);
{
	delete _arg0;
}
    return _resultobj;
}

#define delete_BSMEuropeanOption(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_BSMEuropeanOption(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BSMEuropeanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_BSMEuropeanOption",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_BSMEuropeanOption. Expected _BSMEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    delete_BSMEuropeanOption(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define BSMEuropeanOption_setVolatility(_swigobj,_swigarg0)  (_swigobj->setVolatility(_swigarg0))
static PyObject *_wrap_BSMEuropeanOption_setVolatility(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BSMEuropeanOption * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:BSMEuropeanOption_setVolatility",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMEuropeanOption_setVolatility. Expected _BSMEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    BSMEuropeanOption_setVolatility(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define BSMEuropeanOption_setRiskFreeRate(_swigobj,_swigarg0)  (_swigobj->setRiskFreeRate(_swigarg0))
static PyObject *_wrap_BSMEuropeanOption_setRiskFreeRate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BSMEuropeanOption * _arg0;
    Rate  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:BSMEuropeanOption_setRiskFreeRate",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMEuropeanOption_setRiskFreeRate. Expected _BSMEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    BSMEuropeanOption_setRiskFreeRate(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define BSMEuropeanOption_value(_swigobj)  (_swigobj->value())
static PyObject *_wrap_BSMEuropeanOption_value(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BSMEuropeanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:BSMEuropeanOption_value",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMEuropeanOption_value. Expected _BSMEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BSMEuropeanOption_value(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define BSMEuropeanOption_delta(_swigobj)  (_swigobj->delta())
static PyObject *_wrap_BSMEuropeanOption_delta(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BSMEuropeanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:BSMEuropeanOption_delta",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMEuropeanOption_delta. Expected _BSMEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BSMEuropeanOption_delta(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define BSMEuropeanOption_gamma(_swigobj)  (_swigobj->gamma())
static PyObject *_wrap_BSMEuropeanOption_gamma(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BSMEuropeanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:BSMEuropeanOption_gamma",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMEuropeanOption_gamma. Expected _BSMEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BSMEuropeanOption_gamma(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define BSMEuropeanOption_theta(_swigobj)  (_swigobj->theta())
static PyObject *_wrap_BSMEuropeanOption_theta(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BSMEuropeanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:BSMEuropeanOption_theta",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMEuropeanOption_theta. Expected _BSMEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BSMEuropeanOption_theta(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define BSMEuropeanOption_vega(_swigobj)  (_swigobj->vega())
static PyObject *_wrap_BSMEuropeanOption_vega(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BSMEuropeanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:BSMEuropeanOption_vega",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMEuropeanOption_vega. Expected _BSMEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BSMEuropeanOption_vega(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define BSMEuropeanOption_rho(_swigobj)  (_swigobj->rho())
static PyObject *_wrap_BSMEuropeanOption_rho(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BSMEuropeanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:BSMEuropeanOption_rho",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMEuropeanOption_rho. Expected _BSMEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BSMEuropeanOption_rho(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define BSMEuropeanOption_impliedVolatility(_swigobj,_swigarg0,_swigarg1,_swigarg2)  (_swigobj->impliedVolatility(_swigarg0,_swigarg1,_swigarg2))
static PyObject *_wrap_BSMEuropeanOption_impliedVolatility(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BSMEuropeanOption * _arg0;
    double  _arg1;
    double  _arg2 = 1e-4;
    int  _arg3 = 100;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd|di:BSMEuropeanOption_impliedVolatility",&_argc0,&_arg1,&_arg2,&_arg3)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMEuropeanOption_impliedVolatility. Expected _BSMEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BSMEuropeanOption_impliedVolatility(_arg0,_arg1,_arg2,_arg3);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define new_BSMAmericanOption(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4,_swigarg5,_swigarg6,_swigarg7,_swigarg8) (new BSMAmericanOption(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4,_swigarg5,_swigarg6,_swigarg7,_swigarg8))
static PyObject *_wrap_new_BSMAmericanOption(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BSMAmericanOption * _result;
    OptionType * _arg0;
    double  _arg1;
    double  _arg2;
    Rate  _arg3;
    Rate  _arg4;
    Time  _arg5;
    double  _arg6;
    int  _arg7 = 100;
    int  _arg8 = 100;
    PyObject * _obj0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"Odddddd|ii:new_BSMAmericanOption",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4,&_arg5,&_arg6,&_arg7,&_arg8)) 
        return NULL;
{
	if (PyString_Check(_obj0)) {
		_arg0 = new OptionType;
		std::string s(PyString_AsString(_obj0));
		s = StringFormatter::toLowercase(s);
		if (s == "call")				*(_arg0) = Option::Call;
		else if (s == "put")			*(_arg0) = Option::Put;
		else if (s == "straddle")		*(_arg0) = Option::Straddle;
		else {
			PyErr_SetString(PyExc_TypeError,"unknown option type");
			delete _arg0;
			return NULL;
		}
	} else {
		PyErr_SetString(PyExc_TypeError,"not an option type");
		return NULL;
	}
}
{
	try {
		    _result = (BSMAmericanOption *)new_BSMAmericanOption(*_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_BSMAmericanOption_p");
    _resultobj = Py_BuildValue("s",_ptemp);
{
	delete _arg0;
}
    return _resultobj;
}

#define delete_BSMAmericanOption(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_BSMAmericanOption(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BSMAmericanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_BSMAmericanOption",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_BSMAmericanOption. Expected _BSMAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    delete_BSMAmericanOption(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define BSMAmericanOption_setVolatility(_swigobj,_swigarg0)  (_swigobj->setVolatility(_swigarg0))
static PyObject *_wrap_BSMAmericanOption_setVolatility(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BSMAmericanOption * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:BSMAmericanOption_setVolatility",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMAmericanOption_setVolatility. Expected _BSMAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    BSMAmericanOption_setVolatility(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define BSMAmericanOption_setRiskFreeRate(_swigobj,_swigarg0)  (_swigobj->setRiskFreeRate(_swigarg0))
static PyObject *_wrap_BSMAmericanOption_setRiskFreeRate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    BSMAmericanOption * _arg0;
    Rate  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:BSMAmericanOption_setRiskFreeRate",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMAmericanOption_setRiskFreeRate. Expected _BSMAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    BSMAmericanOption_setRiskFreeRate(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define BSMAmericanOption_value(_swigobj)  (_swigobj->value())
static PyObject *_wrap_BSMAmericanOption_value(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BSMAmericanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:BSMAmericanOption_value",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMAmericanOption_value. Expected _BSMAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BSMAmericanOption_value(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define BSMAmericanOption_delta(_swigobj)  (_swigobj->delta())
static PyObject *_wrap_BSMAmericanOption_delta(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BSMAmericanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:BSMAmericanOption_delta",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMAmericanOption_delta. Expected _BSMAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BSMAmericanOption_delta(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define BSMAmericanOption_gamma(_swigobj)  (_swigobj->gamma())
static PyObject *_wrap_BSMAmericanOption_gamma(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BSMAmericanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:BSMAmericanOption_gamma",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMAmericanOption_gamma. Expected _BSMAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BSMAmericanOption_gamma(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define BSMAmericanOption_theta(_swigobj)  (_swigobj->theta())
static PyObject *_wrap_BSMAmericanOption_theta(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BSMAmericanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:BSMAmericanOption_theta",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMAmericanOption_theta. Expected _BSMAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BSMAmericanOption_theta(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define BSMAmericanOption_vega(_swigobj)  (_swigobj->vega())
static PyObject *_wrap_BSMAmericanOption_vega(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BSMAmericanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:BSMAmericanOption_vega",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMAmericanOption_vega. Expected _BSMAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BSMAmericanOption_vega(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define BSMAmericanOption_rho(_swigobj)  (_swigobj->rho())
static PyObject *_wrap_BSMAmericanOption_rho(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BSMAmericanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:BSMAmericanOption_rho",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMAmericanOption_rho. Expected _BSMAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BSMAmericanOption_rho(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define BSMAmericanOption_impliedVolatility(_swigobj,_swigarg0,_swigarg1,_swigarg2)  (_swigobj->impliedVolatility(_swigarg0,_swigarg1,_swigarg2))
static PyObject *_wrap_BSMAmericanOption_impliedVolatility(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    BSMAmericanOption * _arg0;
    double  _arg1;
    double  _arg2 = 1e-4;
    int  _arg3 = 100;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd|di:BSMAmericanOption_impliedVolatility",&_argc0,&_arg1,&_arg2,&_arg3)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_BSMAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of BSMAmericanOption_impliedVolatility. Expected _BSMAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )BSMAmericanOption_impliedVolatility(_arg0,_arg1,_arg2,_arg3);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define new_DividendAmericanOption(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4,_swigarg5,_swigarg6,_swigarg7,_swigarg8,_swigarg9,_swigarg10) (new DividendAmericanOption(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4,_swigarg5,_swigarg6,_swigarg7,_swigarg8,_swigarg9,_swigarg10))
static PyObject *_wrap_new_DividendAmericanOption(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DividendAmericanOption * _result;
    OptionType * _arg0;
    double  _arg1;
    double  _arg2;
    Rate  _arg3;
    Rate  _arg4;
    Time  _arg5;
    double  _arg6;
    DoubleVector * _arg7;
    DoubleVector * _arg8;
    int  _arg9 = 100;
    int  _arg10 = 100;
    PyObject * _obj0 = 0;
    PyObject * _obj7 = 0;
    PyObject * _obj8 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"OddddddOO|ii:new_DividendAmericanOption",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4,&_arg5,&_arg6,&_obj7,&_obj8,&_arg9,&_arg10)) 
        return NULL;
{
	if (PyString_Check(_obj0)) {
		_arg0 = new OptionType;
		std::string s(PyString_AsString(_obj0));
		s = StringFormatter::toLowercase(s);
		if (s == "call")				*(_arg0) = Option::Call;
		else if (s == "put")			*(_arg0) = Option::Put;
		else if (s == "straddle")		*(_arg0) = Option::Straddle;
		else {
			PyErr_SetString(PyExc_TypeError,"unknown option type");
			delete _arg0;
			return NULL;
		}
	} else {
		PyErr_SetString(PyExc_TypeError,"not an option type");
		return NULL;
	}
}
{
    if (PyTuple_Check(_obj7)) {
        int size = PyTuple_Size(_obj7);
        _arg7 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj7,i);
            if (PyFloat_Check(o)) {
                (*_arg7)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg7)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg7)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg7;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj7)) {
        int size = PyList_Size(_obj7);
        _arg7 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj7,i);
            if (PyFloat_Check(o)) {
                (*_arg7)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg7)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg7)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg7;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
    if (PyTuple_Check(_obj8)) {
        int size = PyTuple_Size(_obj8);
        _arg8 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj8,i);
            if (PyFloat_Check(o)) {
                (*_arg8)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg8)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg8)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg8;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj8)) {
        int size = PyList_Size(_obj8);
        _arg8 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj8,i);
            if (PyFloat_Check(o)) {
                (*_arg8)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg8)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg8)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg8;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
	try {
		    _result = (DividendAmericanOption *)new_DividendAmericanOption(*_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,*_arg7,*_arg8,_arg9,_arg10);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_DividendAmericanOption_p");
    _resultobj = Py_BuildValue("s",_ptemp);
{
	delete _arg0;
}
{
    delete _arg7;
}
{
    delete _arg8;
}
    return _resultobj;
}

#define delete_DividendAmericanOption(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_DividendAmericanOption(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DividendAmericanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_DividendAmericanOption",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_DividendAmericanOption. Expected _DividendAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    delete_DividendAmericanOption(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define DividendAmericanOption_value(_swigobj)  (_swigobj->value())
static PyObject *_wrap_DividendAmericanOption_value(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    DividendAmericanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DividendAmericanOption_value",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DividendAmericanOption_value. Expected _DividendAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )DividendAmericanOption_value(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define DividendAmericanOption_delta(_swigobj)  (_swigobj->delta())
static PyObject *_wrap_DividendAmericanOption_delta(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    DividendAmericanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DividendAmericanOption_delta",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DividendAmericanOption_delta. Expected _DividendAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )DividendAmericanOption_delta(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define DividendAmericanOption_gamma(_swigobj)  (_swigobj->gamma())
static PyObject *_wrap_DividendAmericanOption_gamma(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    DividendAmericanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DividendAmericanOption_gamma",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DividendAmericanOption_gamma. Expected _DividendAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )DividendAmericanOption_gamma(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define DividendAmericanOption_theta(_swigobj)  (_swigobj->theta())
static PyObject *_wrap_DividendAmericanOption_theta(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    DividendAmericanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DividendAmericanOption_theta",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DividendAmericanOption_theta. Expected _DividendAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )DividendAmericanOption_theta(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define DividendAmericanOption_vega(_swigobj)  (_swigobj->vega())
static PyObject *_wrap_DividendAmericanOption_vega(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    DividendAmericanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DividendAmericanOption_vega",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DividendAmericanOption_vega. Expected _DividendAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )DividendAmericanOption_vega(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define DividendAmericanOption_rho(_swigobj)  (_swigobj->rho())
static PyObject *_wrap_DividendAmericanOption_rho(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    DividendAmericanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DividendAmericanOption_rho",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DividendAmericanOption_rho. Expected _DividendAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )DividendAmericanOption_rho(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define DividendAmericanOption_impliedVolatility(_swigobj,_swigarg0,_swigarg1,_swigarg2)  (_swigobj->impliedVolatility(_swigarg0,_swigarg1,_swigarg2))
static PyObject *_wrap_DividendAmericanOption_impliedVolatility(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    DividendAmericanOption * _arg0;
    double  _arg1;
    double  _arg2 = 1e-4;
    int  _arg3 = 100;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd|di:DividendAmericanOption_impliedVolatility",&_argc0,&_arg1,&_arg2,&_arg3)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendAmericanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DividendAmericanOption_impliedVolatility. Expected _DividendAmericanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )DividendAmericanOption_impliedVolatility(_arg0,_arg1,_arg2,_arg3);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define new_DividendEuropeanOption(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4,_swigarg5,_swigarg6,_swigarg7,_swigarg8) (new DividendEuropeanOption(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4,_swigarg5,_swigarg6,_swigarg7,_swigarg8))
static PyObject *_wrap_new_DividendEuropeanOption(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DividendEuropeanOption * _result;
    OptionType * _arg0;
    double  _arg1;
    double  _arg2;
    Rate  _arg3;
    Rate  _arg4;
    Time  _arg5;
    double  _arg6;
    DoubleVector * _arg7;
    DoubleVector * _arg8;
    PyObject * _obj0 = 0;
    PyObject * _obj7 = 0;
    PyObject * _obj8 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"OddddddOO:new_DividendEuropeanOption",&_obj0,&_arg1,&_arg2,&_arg3,&_arg4,&_arg5,&_arg6,&_obj7,&_obj8)) 
        return NULL;
{
	if (PyString_Check(_obj0)) {
		_arg0 = new OptionType;
		std::string s(PyString_AsString(_obj0));
		s = StringFormatter::toLowercase(s);
		if (s == "call")				*(_arg0) = Option::Call;
		else if (s == "put")			*(_arg0) = Option::Put;
		else if (s == "straddle")		*(_arg0) = Option::Straddle;
		else {
			PyErr_SetString(PyExc_TypeError,"unknown option type");
			delete _arg0;
			return NULL;
		}
	} else {
		PyErr_SetString(PyExc_TypeError,"not an option type");
		return NULL;
	}
}
{
    if (PyTuple_Check(_obj7)) {
        int size = PyTuple_Size(_obj7);
        _arg7 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj7,i);
            if (PyFloat_Check(o)) {
                (*_arg7)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg7)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg7)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg7;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj7)) {
        int size = PyList_Size(_obj7);
        _arg7 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj7,i);
            if (PyFloat_Check(o)) {
                (*_arg7)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg7)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg7)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg7;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
    if (PyTuple_Check(_obj8)) {
        int size = PyTuple_Size(_obj8);
        _arg8 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj8,i);
            if (PyFloat_Check(o)) {
                (*_arg8)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg8)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg8)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg8;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj8)) {
        int size = PyList_Size(_obj8);
        _arg8 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj8,i);
            if (PyFloat_Check(o)) {
                (*_arg8)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg8)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg8)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg8;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
	try {
		    _result = (DividendEuropeanOption *)new_DividendEuropeanOption(*_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,*_arg7,*_arg8);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_DividendEuropeanOption_p");
    _resultobj = Py_BuildValue("s",_ptemp);
{
	delete _arg0;
}
{
    delete _arg7;
}
{
    delete _arg8;
}
    return _resultobj;
}

#define delete_DividendEuropeanOption(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_DividendEuropeanOption(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    DividendEuropeanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_DividendEuropeanOption",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_DividendEuropeanOption. Expected _DividendEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    delete_DividendEuropeanOption(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define DividendEuropeanOption_value(_swigobj)  (_swigobj->value())
static PyObject *_wrap_DividendEuropeanOption_value(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    DividendEuropeanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DividendEuropeanOption_value",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DividendEuropeanOption_value. Expected _DividendEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )DividendEuropeanOption_value(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define DividendEuropeanOption_delta(_swigobj)  (_swigobj->delta())
static PyObject *_wrap_DividendEuropeanOption_delta(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    DividendEuropeanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DividendEuropeanOption_delta",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DividendEuropeanOption_delta. Expected _DividendEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )DividendEuropeanOption_delta(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define DividendEuropeanOption_gamma(_swigobj)  (_swigobj->gamma())
static PyObject *_wrap_DividendEuropeanOption_gamma(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    DividendEuropeanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DividendEuropeanOption_gamma",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DividendEuropeanOption_gamma. Expected _DividendEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )DividendEuropeanOption_gamma(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define DividendEuropeanOption_theta(_swigobj)  (_swigobj->theta())
static PyObject *_wrap_DividendEuropeanOption_theta(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    DividendEuropeanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DividendEuropeanOption_theta",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DividendEuropeanOption_theta. Expected _DividendEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )DividendEuropeanOption_theta(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define DividendEuropeanOption_vega(_swigobj)  (_swigobj->vega())
static PyObject *_wrap_DividendEuropeanOption_vega(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    DividendEuropeanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DividendEuropeanOption_vega",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DividendEuropeanOption_vega. Expected _DividendEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )DividendEuropeanOption_vega(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define DividendEuropeanOption_rho(_swigobj)  (_swigobj->rho())
static PyObject *_wrap_DividendEuropeanOption_rho(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    DividendEuropeanOption * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:DividendEuropeanOption_rho",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DividendEuropeanOption_rho. Expected _DividendEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )DividendEuropeanOption_rho(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define DividendEuropeanOption_impliedVolatility(_swigobj,_swigarg0,_swigarg1,_swigarg2)  (_swigobj->impliedVolatility(_swigarg0,_swigarg1,_swigarg2))
static PyObject *_wrap_DividendEuropeanOption_impliedVolatility(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    DividendEuropeanOption * _arg0;
    double  _arg1;
    double  _arg2 = 1e-4;
    int  _arg3 = 100;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd|di:DividendEuropeanOption_impliedVolatility",&_argc0,&_arg1,&_arg2,&_arg3)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_DividendEuropeanOption_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of DividendEuropeanOption_impliedVolatility. Expected _DividendEuropeanOption_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )DividendEuropeanOption_impliedVolatility(_arg0,_arg1,_arg2,_arg3);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define new_UniformRandomGenerator(_swigarg0) (new UniformRandomGenerator(_swigarg0))
static PyObject *_wrap_new_UniformRandomGenerator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    UniformRandomGenerator * _result;
    long  _arg0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"|l:new_UniformRandomGenerator",&_arg0)) 
        return NULL;
{
	try {
		    _result = (UniformRandomGenerator *)new_UniformRandomGenerator(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_UniformRandomGenerator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_UniformRandomGenerator(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_UniformRandomGenerator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    UniformRandomGenerator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_UniformRandomGenerator",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_UniformRandomGenerator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_UniformRandomGenerator. Expected _UniformRandomGenerator_p.");
        return NULL;
        }
    }
{
	try {
		    delete_UniformRandomGenerator(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define UniformRandomGenerator_next(_swigobj)  (_swigobj->next())
static PyObject *_wrap_UniformRandomGenerator_next(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    UniformRandomGenerator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:UniformRandomGenerator_next",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_UniformRandomGenerator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of UniformRandomGenerator_next. Expected _UniformRandomGenerator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )UniformRandomGenerator_next(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define UniformRandomGenerator_weight(_swigobj)  (_swigobj->weight())
static PyObject *_wrap_UniformRandomGenerator_weight(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    UniformRandomGenerator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:UniformRandomGenerator_weight",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_UniformRandomGenerator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of UniformRandomGenerator_weight. Expected _UniformRandomGenerator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )UniformRandomGenerator_weight(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define new_GaussianRandomGenerator(_swigarg0) (new GaussianRandomGenerator(_swigarg0))
static PyObject *_wrap_new_GaussianRandomGenerator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    GaussianRandomGenerator * _result;
    long  _arg0 = 0;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,"|l:new_GaussianRandomGenerator",&_arg0)) 
        return NULL;
{
	try {
		    _result = (GaussianRandomGenerator *)new_GaussianRandomGenerator(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_GaussianRandomGenerator_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_GaussianRandomGenerator(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_GaussianRandomGenerator(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    GaussianRandomGenerator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_GaussianRandomGenerator",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_GaussianRandomGenerator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_GaussianRandomGenerator. Expected _GaussianRandomGenerator_p.");
        return NULL;
        }
    }
{
	try {
		    delete_GaussianRandomGenerator(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define GaussianRandomGenerator_next(_swigobj)  (_swigobj->next())
static PyObject *_wrap_GaussianRandomGenerator_next(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    GaussianRandomGenerator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:GaussianRandomGenerator_next",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_GaussianRandomGenerator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of GaussianRandomGenerator_next. Expected _GaussianRandomGenerator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )GaussianRandomGenerator_next(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define GaussianRandomGenerator_weight(_swigobj)  (_swigobj->weight())
static PyObject *_wrap_GaussianRandomGenerator_weight(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    GaussianRandomGenerator * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:GaussianRandomGenerator_weight",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_GaussianRandomGenerator_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of GaussianRandomGenerator_weight. Expected _GaussianRandomGenerator_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )GaussianRandomGenerator_weight(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define new_RiskTool() (new RiskTool())
static PyObject *_wrap_new_RiskTool(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    RiskTool * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":new_RiskTool")) 
        return NULL;
{
	try {
		    _result = (RiskTool *)new_RiskTool();

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_RiskTool_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_RiskTool(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_RiskTool(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    RiskTool * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_RiskTool",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_RiskTool. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    delete_RiskTool(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define RiskTool_samples(_swigobj)  (_swigobj->samples())
static PyObject *_wrap_RiskTool_samples(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    RiskTool * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:RiskTool_samples",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_samples. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )RiskTool_samples(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define RiskTool_weightSum(_swigobj)  (_swigobj->weightSum())
static PyObject *_wrap_RiskTool_weightSum(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    RiskTool * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:RiskTool_weightSum",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_weightSum. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )RiskTool_weightSum(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define RiskTool_mean(_swigobj)  (_swigobj->mean())
static PyObject *_wrap_RiskTool_mean(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    RiskTool * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:RiskTool_mean",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_mean. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )RiskTool_mean(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define RiskTool_variance(_swigobj)  (_swigobj->variance())
static PyObject *_wrap_RiskTool_variance(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    RiskTool * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:RiskTool_variance",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_variance. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )RiskTool_variance(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define RiskTool_standardDeviation(_swigobj)  (_swigobj->standardDeviation())
static PyObject *_wrap_RiskTool_standardDeviation(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    RiskTool * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:RiskTool_standardDeviation",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_standardDeviation. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )RiskTool_standardDeviation(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define RiskTool_errorEstimate(_swigobj)  (_swigobj->errorEstimate())
static PyObject *_wrap_RiskTool_errorEstimate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    RiskTool * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:RiskTool_errorEstimate",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_errorEstimate. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )RiskTool_errorEstimate(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define RiskTool_skewness(_swigobj)  (_swigobj->skewness())
static PyObject *_wrap_RiskTool_skewness(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    RiskTool * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:RiskTool_skewness",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_skewness. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )RiskTool_skewness(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define RiskTool_kurtosis(_swigobj)  (_swigobj->kurtosis())
static PyObject *_wrap_RiskTool_kurtosis(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    RiskTool * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:RiskTool_kurtosis",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_kurtosis. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )RiskTool_kurtosis(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define RiskTool_min(_swigobj)  (_swigobj->min())
static PyObject *_wrap_RiskTool_min(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    RiskTool * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:RiskTool_min",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_min. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )RiskTool_min(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define RiskTool_max(_swigobj)  (_swigobj->max())
static PyObject *_wrap_RiskTool_max(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    RiskTool * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:RiskTool_max",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_max. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )RiskTool_max(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define RiskTool_valueAtRisk(_swigobj,_swigarg0)  (_swigobj->valueAtRisk(_swigarg0))
static PyObject *_wrap_RiskTool_valueAtRisk(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    RiskTool * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:RiskTool_valueAtRisk",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_valueAtRisk. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )RiskTool_valueAtRisk(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define RiskTool_shortfall(_swigobj,_swigarg0)  (_swigobj->shortfall(_swigarg0))
static PyObject *_wrap_RiskTool_shortfall(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    RiskTool * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:RiskTool_shortfall",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_shortfall. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )RiskTool_shortfall(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define RiskTool_averageShortfall(_swigobj,_swigarg0)  (_swigobj->averageShortfall(_swigarg0))
static PyObject *_wrap_RiskTool_averageShortfall(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    RiskTool * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:RiskTool_averageShortfall",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_averageShortfall. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )RiskTool_averageShortfall(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define RiskTool_add(_swigobj,_swigarg0,_swigarg1)  (_swigobj->add(_swigarg0,_swigarg1))
static PyObject *_wrap_RiskTool_add(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    RiskTool * _arg0;
    double  _arg1;
    double  _arg2 = 1.0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd|d:RiskTool_add",&_argc0,&_arg1,&_arg2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_add. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    RiskTool_add(_arg0,_arg1,_arg2);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define RiskTool_reset(_swigobj)  (_swigobj->reset())
static PyObject *_wrap_RiskTool_reset(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    RiskTool * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:RiskTool_reset",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_reset. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
	try {
		    RiskTool_reset(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  RiskTool_addSequence(RiskTool *self,DoubleVector  values) {
	  self->addSequence(values.begin(), values.end());
	}
static PyObject *_wrap_RiskTool_addSequence(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    RiskTool * _arg0;
    DoubleVector * _arg1;
    char * _argc0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sO:RiskTool_addSequence",&_argc0,&_obj1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_addSequence. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
    if (PyTuple_Check(_obj1)) {
        int size = PyTuple_Size(_obj1);
        _arg1 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj1)) {
        int size = PyList_Size(_obj1);
        _arg1 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
	try {
		    RiskTool_addSequence(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
{
    delete _arg1;
}
    return _resultobj;
}

static void  RiskTool_addWeightedSequence(RiskTool *self,DoubleVector  values,DoubleVector  weights) {
	  self->addSequence(values.begin(), values.end(), weights.begin());
	}
static PyObject *_wrap_RiskTool_addWeightedSequence(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    RiskTool * _arg0;
    DoubleVector * _arg1;
    DoubleVector * _arg2;
    char * _argc0 = 0;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sOO:RiskTool_addWeightedSequence",&_argc0,&_obj1,&_obj2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_RiskTool_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of RiskTool_addWeightedSequence. Expected _RiskTool_p.");
        return NULL;
        }
    }
{
    if (PyTuple_Check(_obj1)) {
        int size = PyTuple_Size(_obj1);
        _arg1 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj1)) {
        int size = PyList_Size(_obj1);
        _arg1 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
    if (PyTuple_Check(_obj2)) {
        int size = PyTuple_Size(_obj2);
        _arg2 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj2,i);
            if (PyFloat_Check(o)) {
                (*_arg2)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg2)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg2)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg2;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj2)) {
        int size = PyList_Size(_obj2);
        _arg2 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj2,i);
            if (PyFloat_Check(o)) {
                (*_arg2)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg2)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg2)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg2;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
	try {
		    RiskTool_addWeightedSequence(_arg0,*_arg1,*_arg2);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
{
    delete _arg1;
}
{
    delete _arg2;
}
    return _resultobj;
}

#define ObjectiveFunction_value(_swigobj,_swigarg0)  (_swigobj->value(_swigarg0))
static PyObject *_wrap_ObjectiveFunction_value(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    ObjectiveFunction * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:ObjectiveFunction_value",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ObjectiveFunction_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ObjectiveFunction_value. Expected _ObjectiveFunction_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )ObjectiveFunction_value(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define ObjectiveFunction_derivative(_swigobj,_swigarg0)  (_swigobj->derivative(_swigarg0))
static PyObject *_wrap_ObjectiveFunction_derivative(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    ObjectiveFunction * _arg0;
    double  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd:ObjectiveFunction_derivative",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_ObjectiveFunction_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of ObjectiveFunction_derivative. Expected _ObjectiveFunction_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )ObjectiveFunction_derivative(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define Solver1D_solve(_swigobj,_swigarg0,_swigarg1,_swigarg2,_swigarg3)  (_swigobj->solve(_swigarg0,_swigarg1,_swigarg2,_swigarg3))
static PyObject *_wrap_Solver1D_solve(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Solver1D * _arg0;
    ObjectiveFunction * _arg1;
    double  _arg2;
    double  _arg3;
    double  _arg4;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ssddd:Solver1D_solve",&_argc0,&_argc1,&_arg2,&_arg3,&_arg4)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Solver1D_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Solver1D_solve. Expected _Solver1D_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_ObjectiveFunction_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of Solver1D_solve. Expected _ObjectiveFunction_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )Solver1D_solve(_arg0,*_arg1,_arg2,_arg3,_arg4);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define Solver1D_bracketedSolve(_swigobj,_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4)  (_swigobj->solve(_swigarg0,_swigarg1,_swigarg2,_swigarg3,_swigarg4))
static PyObject *_wrap_Solver1D_bracketedSolve(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Solver1D * _arg0;
    ObjectiveFunction * _arg1;
    double  _arg2;
    double  _arg3;
    double  _arg4;
    double  _arg5;
    char * _argc0 = 0;
    char * _argc1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"ssdddd:Solver1D_bracketedSolve",&_argc0,&_argc1,&_arg2,&_arg3,&_arg4,&_arg5)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Solver1D_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Solver1D_bracketedSolve. Expected _Solver1D_p.");
        return NULL;
        }
    }
    if (_argc1) {
        if (SWIG_GetPtr(_argc1,(void **) &_arg1,"_ObjectiveFunction_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 2 of Solver1D_bracketedSolve. Expected _ObjectiveFunction_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )Solver1D_bracketedSolve(_arg0,*_arg1,_arg2,_arg3,_arg4,_arg5);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define Solver1D_setMaxEvaluations(_swigobj,_swigarg0)  (_swigobj->setMaxEvaluations(_swigarg0))
static PyObject *_wrap_Solver1D_setMaxEvaluations(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Solver1D * _arg0;
    int  _arg1;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"si:Solver1D_setMaxEvaluations",&_argc0,&_arg1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Solver1D_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Solver1D_setMaxEvaluations. Expected _Solver1D_p.");
        return NULL;
        }
    }
{
	try {
		    Solver1D_setMaxEvaluations(_arg0,_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static double  Solver1D_pySolve(Solver1D *self,PyObject * pyFunction,double  xAccuracy,double  guess,double  step) {
		PyObjectiveFunction f(pyFunction);
		return self->solve(f, xAccuracy, guess, step);
	}
static PyObject *_wrap_Solver1D_pySolve(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Solver1D * _arg0;
    PyObject * _arg1;
    double  _arg2;
    double  _arg3;
    double  _arg4;
    char * _argc0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sOddd:Solver1D_pySolve",&_argc0,&_obj1,&_arg2,&_arg3,&_arg4)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Solver1D_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Solver1D_pySolve. Expected _Solver1D_p.");
        return NULL;
        }
    }
{
	_arg1 = _obj1;
}
{
	try {
		    _result = (double )Solver1D_pySolve(_arg0,_arg1,_arg2,_arg3,_arg4);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static double  Solver1D_pyBracketedSolve(Solver1D *self,PyObject * pyFunction,double  xAccuracy,double  guess,double  xMin,double  xMax) {
		PyObjectiveFunction f(pyFunction);
		return self->solve(f, xAccuracy, guess, xMin, xMax);
	}
static PyObject *_wrap_Solver1D_pyBracketedSolve(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Solver1D * _arg0;
    PyObject * _arg1;
    double  _arg2;
    double  _arg3;
    double  _arg4;
    double  _arg5;
    char * _argc0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sOdddd:Solver1D_pyBracketedSolve",&_argc0,&_obj1,&_arg2,&_arg3,&_arg4,&_arg5)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Solver1D_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Solver1D_pyBracketedSolve. Expected _Solver1D_p.");
        return NULL;
        }
    }
{
	_arg1 = _obj1;
}
{
	try {
		    _result = (double )Solver1D_pyBracketedSolve(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

static void *SwigBisectionToSolver1D(void *ptr) {
    Bisection *src;
    Solver1D *dest;
    src = (Bisection *) ptr;
    dest = (Solver1D *) src;
    return (void *) dest;
}

#define new_Bisection() (new Bisection())
static PyObject *_wrap_new_Bisection(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Bisection * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":new_Bisection")) 
        return NULL;
{
	try {
		    _result = (Bisection *)new_Bisection();

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_Bisection_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_Bisection(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_Bisection(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Bisection * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_Bisection",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Bisection_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_Bisection. Expected _Bisection_p.");
        return NULL;
        }
    }
{
	try {
		    delete_Bisection(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void *SwigBrentToSolver1D(void *ptr) {
    Brent *src;
    Solver1D *dest;
    src = (Brent *) ptr;
    dest = (Solver1D *) src;
    return (void *) dest;
}

#define new_Brent() (new Brent())
static PyObject *_wrap_new_Brent(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Brent * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":new_Brent")) 
        return NULL;
{
	try {
		    _result = (Brent *)new_Brent();

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_Brent_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_Brent(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_Brent(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Brent * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_Brent",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Brent_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_Brent. Expected _Brent_p.");
        return NULL;
        }
    }
{
	try {
		    delete_Brent(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void *SwigFalsePositionToSolver1D(void *ptr) {
    FalsePosition *src;
    Solver1D *dest;
    src = (FalsePosition *) ptr;
    dest = (Solver1D *) src;
    return (void *) dest;
}

#define new_FalsePosition() (new FalsePosition())
static PyObject *_wrap_new_FalsePosition(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    FalsePosition * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":new_FalsePosition")) 
        return NULL;
{
	try {
		    _result = (FalsePosition *)new_FalsePosition();

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_FalsePosition_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_FalsePosition(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_FalsePosition(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    FalsePosition * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_FalsePosition",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_FalsePosition_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_FalsePosition. Expected _FalsePosition_p.");
        return NULL;
        }
    }
{
	try {
		    delete_FalsePosition(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void *SwigNewtonToSolver1D(void *ptr) {
    Newton *src;
    Solver1D *dest;
    src = (Newton *) ptr;
    dest = (Solver1D *) src;
    return (void *) dest;
}

#define new_Newton() (new Newton())
static PyObject *_wrap_new_Newton(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Newton * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":new_Newton")) 
        return NULL;
{
	try {
		    _result = (Newton *)new_Newton();

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_Newton_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_Newton(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_Newton(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Newton * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_Newton",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Newton_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_Newton. Expected _Newton_p.");
        return NULL;
        }
    }
{
	try {
		    delete_Newton(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void *SwigNewtonSafeToSolver1D(void *ptr) {
    NewtonSafe *src;
    Solver1D *dest;
    src = (NewtonSafe *) ptr;
    dest = (Solver1D *) src;
    return (void *) dest;
}

#define new_NewtonSafe() (new NewtonSafe())
static PyObject *_wrap_new_NewtonSafe(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    NewtonSafe * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":new_NewtonSafe")) 
        return NULL;
{
	try {
		    _result = (NewtonSafe *)new_NewtonSafe();

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_NewtonSafe_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_NewtonSafe(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_NewtonSafe(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    NewtonSafe * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_NewtonSafe",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_NewtonSafe_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_NewtonSafe. Expected _NewtonSafe_p.");
        return NULL;
        }
    }
{
	try {
		    delete_NewtonSafe(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void *SwigRidderToSolver1D(void *ptr) {
    Ridder *src;
    Solver1D *dest;
    src = (Ridder *) ptr;
    dest = (Solver1D *) src;
    return (void *) dest;
}

#define new_Ridder() (new Ridder())
static PyObject *_wrap_new_Ridder(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Ridder * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":new_Ridder")) 
        return NULL;
{
	try {
		    _result = (Ridder *)new_Ridder();

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_Ridder_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_Ridder(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_Ridder(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Ridder * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_Ridder",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Ridder_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_Ridder. Expected _Ridder_p.");
        return NULL;
        }
    }
{
	try {
		    delete_Ridder(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void *SwigSecantToSolver1D(void *ptr) {
    Secant *src;
    Solver1D *dest;
    src = (Secant *) ptr;
    dest = (Solver1D *) src;
    return (void *) dest;
}

#define new_Secant() (new Secant())
static PyObject *_wrap_new_Secant(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Secant * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":new_Secant")) 
        return NULL;
{
	try {
		    _result = (Secant *)new_Secant();

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_Secant_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_Secant(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_Secant(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Secant * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_Secant",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Secant_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_Secant. Expected _Secant_p.");
        return NULL;
        }
    }
{
	try {
		    delete_Secant(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define new_Statistics() (new Statistics())
static PyObject *_wrap_new_Statistics(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Statistics * _result;
    char _ptemp[128];

    self = self;
    if(!PyArg_ParseTuple(args,":new_Statistics")) 
        return NULL;
{
	try {
		    _result = (Statistics *)new_Statistics();

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    SWIG_MakePtr(_ptemp, (char *) _result,"_Statistics_p");
    _resultobj = Py_BuildValue("s",_ptemp);
    return _resultobj;
}

#define delete_Statistics(_swigobj) (delete _swigobj)
static PyObject *_wrap_delete_Statistics(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Statistics * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:delete_Statistics",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of delete_Statistics. Expected _Statistics_p.");
        return NULL;
        }
    }
{
	try {
		    delete_Statistics(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define Statistics_samples(_swigobj)  (_swigobj->samples())
static PyObject *_wrap_Statistics_samples(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    int  _result;
    Statistics * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Statistics_samples",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Statistics_samples. Expected _Statistics_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (int )Statistics_samples(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("i",_result);
    return _resultobj;
}

#define Statistics_weightSum(_swigobj)  (_swigobj->weightSum())
static PyObject *_wrap_Statistics_weightSum(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Statistics * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Statistics_weightSum",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Statistics_weightSum. Expected _Statistics_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )Statistics_weightSum(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define Statistics_mean(_swigobj)  (_swigobj->mean())
static PyObject *_wrap_Statistics_mean(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Statistics * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Statistics_mean",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Statistics_mean. Expected _Statistics_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )Statistics_mean(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define Statistics_variance(_swigobj)  (_swigobj->variance())
static PyObject *_wrap_Statistics_variance(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Statistics * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Statistics_variance",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Statistics_variance. Expected _Statistics_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )Statistics_variance(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define Statistics_standardDeviation(_swigobj)  (_swigobj->standardDeviation())
static PyObject *_wrap_Statistics_standardDeviation(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Statistics * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Statistics_standardDeviation",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Statistics_standardDeviation. Expected _Statistics_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )Statistics_standardDeviation(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define Statistics_errorEstimate(_swigobj)  (_swigobj->errorEstimate())
static PyObject *_wrap_Statistics_errorEstimate(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Statistics * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Statistics_errorEstimate",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Statistics_errorEstimate. Expected _Statistics_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )Statistics_errorEstimate(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define Statistics_skewness(_swigobj)  (_swigobj->skewness())
static PyObject *_wrap_Statistics_skewness(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Statistics * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Statistics_skewness",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Statistics_skewness. Expected _Statistics_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )Statistics_skewness(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define Statistics_kurtosis(_swigobj)  (_swigobj->kurtosis())
static PyObject *_wrap_Statistics_kurtosis(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Statistics * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Statistics_kurtosis",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Statistics_kurtosis. Expected _Statistics_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )Statistics_kurtosis(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define Statistics_min(_swigobj)  (_swigobj->min())
static PyObject *_wrap_Statistics_min(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Statistics * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Statistics_min",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Statistics_min. Expected _Statistics_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )Statistics_min(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define Statistics_max(_swigobj)  (_swigobj->max())
static PyObject *_wrap_Statistics_max(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    double  _result;
    Statistics * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Statistics_max",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Statistics_max. Expected _Statistics_p.");
        return NULL;
        }
    }
{
	try {
		    _result = (double )Statistics_max(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    _resultobj = Py_BuildValue("d",_result);
    return _resultobj;
}

#define Statistics_add(_swigobj,_swigarg0,_swigarg1)  (_swigobj->add(_swigarg0,_swigarg1))
static PyObject *_wrap_Statistics_add(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Statistics * _arg0;
    double  _arg1;
    double  _arg2 = 1.0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sd|d:Statistics_add",&_argc0,&_arg1,&_arg2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Statistics_add. Expected _Statistics_p.");
        return NULL;
        }
    }
{
	try {
		    Statistics_add(_arg0,_arg1,_arg2);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

#define Statistics_reset(_swigobj)  (_swigobj->reset())
static PyObject *_wrap_Statistics_reset(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Statistics * _arg0;
    char * _argc0 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"s:Statistics_reset",&_argc0)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Statistics_reset. Expected _Statistics_p.");
        return NULL;
        }
    }
{
	try {
		    Statistics_reset(_arg0);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
    return _resultobj;
}

static void  Statistics_addSequence(Statistics *self,DoubleVector  values) {
	  self->addSequence(values.begin(), values.end());
	}
static PyObject *_wrap_Statistics_addSequence(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Statistics * _arg0;
    DoubleVector * _arg1;
    char * _argc0 = 0;
    PyObject * _obj1 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sO:Statistics_addSequence",&_argc0,&_obj1)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Statistics_addSequence. Expected _Statistics_p.");
        return NULL;
        }
    }
{
    if (PyTuple_Check(_obj1)) {
        int size = PyTuple_Size(_obj1);
        _arg1 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj1)) {
        int size = PyList_Size(_obj1);
        _arg1 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
	try {
		    Statistics_addSequence(_arg0,*_arg1);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
{
    delete _arg1;
}
    return _resultobj;
}

static void  Statistics_addWeightedSequence(Statistics *self,DoubleVector  values,DoubleVector  weights) {
	  self->addSequence(values.begin(), values.end(), weights.begin());
	}
static PyObject *_wrap_Statistics_addWeightedSequence(PyObject *self, PyObject *args) {
    PyObject * _resultobj;
    Statistics * _arg0;
    DoubleVector * _arg1;
    DoubleVector * _arg2;
    char * _argc0 = 0;
    PyObject * _obj1 = 0;
    PyObject * _obj2 = 0;

    self = self;
    if(!PyArg_ParseTuple(args,"sOO:Statistics_addWeightedSequence",&_argc0,&_obj1,&_obj2)) 
        return NULL;
    if (_argc0) {
        if (SWIG_GetPtr(_argc0,(void **) &_arg0,"_Statistics_p")) {
            PyErr_SetString(PyExc_TypeError,"Type error in argument 1 of Statistics_addWeightedSequence. Expected _Statistics_p.");
        return NULL;
        }
    }
{
    if (PyTuple_Check(_obj1)) {
        int size = PyTuple_Size(_obj1);
        _arg1 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj1)) {
        int size = PyList_Size(_obj1);
        _arg1 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj1,i);
            if (PyFloat_Check(o)) {
                (*_arg1)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg1)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg1)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg1;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
    if (PyTuple_Check(_obj2)) {
        int size = PyTuple_Size(_obj2);
        _arg2 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyTuple_GetItem(_obj2,i);
            if (PyFloat_Check(o)) {
                (*_arg2)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg2)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg2)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"tuple must contain doubles");
                delete _arg2;
                return NULL;
            }
        }
    } else if (PyList_Check(_obj2)) {
        int size = PyList_Size(_obj2);
        _arg2 = new DoubleVector (size);
        for (int i=0; i<size; i++) {
            PyObject* o = PyList_GetItem(_obj2,i);
            if (PyFloat_Check(o)) {
                (*_arg2)[i] = PyFloat_AsDouble(o);
            } else if (PyInt_Check(o)) {
                (*_arg2)[i] = double(PyInt_AsLong(o));
            } else if (o == Py_None) {
                (*_arg2)[i] = Null<double>();
            } else {
                PyErr_SetString(PyExc_TypeError,"list must contain doubles");
                delete _arg2;
                return NULL;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,"not a sequence");
        return NULL;
    }
}
{
	try {
		    Statistics_addWeightedSequence(_arg0,*_arg1,*_arg2);

	} catch (std::exception& e) {
		PyErr_SetString(PyExc_Exception,e.what());
		return NULL;
	} catch (...) {
		PyErr_SetString(PyExc_Exception,"unknown error");
		return NULL;
	}
}    Py_INCREF(Py_None);
    _resultobj = Py_None;
{
    delete _arg1;
}
{
    delete _arg2;
}
    return _resultobj;
}

static PyMethodDef QuantLibcMethods[] = {
	 { "Statistics_addWeightedSequence", _wrap_Statistics_addWeightedSequence, 1 },
	 { "Statistics_addSequence", _wrap_Statistics_addSequence, 1 },
	 { "Statistics_reset", _wrap_Statistics_reset, 1 },
	 { "Statistics_add", _wrap_Statistics_add, 1 },
	 { "Statistics_max", _wrap_Statistics_max, 1 },
	 { "Statistics_min", _wrap_Statistics_min, 1 },
	 { "Statistics_kurtosis", _wrap_Statistics_kurtosis, 1 },
	 { "Statistics_skewness", _wrap_Statistics_skewness, 1 },
	 { "Statistics_errorEstimate", _wrap_Statistics_errorEstimate, 1 },
	 { "Statistics_standardDeviation", _wrap_Statistics_standardDeviation, 1 },
	 { "Statistics_variance", _wrap_Statistics_variance, 1 },
	 { "Statistics_mean", _wrap_Statistics_mean, 1 },
	 { "Statistics_weightSum", _wrap_Statistics_weightSum, 1 },
	 { "Statistics_samples", _wrap_Statistics_samples, 1 },
	 { "delete_Statistics", _wrap_delete_Statistics, 1 },
	 { "new_Statistics", _wrap_new_Statistics, 1 },
	 { "delete_Secant", _wrap_delete_Secant, 1 },
	 { "new_Secant", _wrap_new_Secant, 1 },
	 { "delete_Ridder", _wrap_delete_Ridder, 1 },
	 { "new_Ridder", _wrap_new_Ridder, 1 },
	 { "delete_NewtonSafe", _wrap_delete_NewtonSafe, 1 },
	 { "new_NewtonSafe", _wrap_new_NewtonSafe, 1 },
	 { "delete_Newton", _wrap_delete_Newton, 1 },
	 { "new_Newton", _wrap_new_Newton, 1 },
	 { "delete_FalsePosition", _wrap_delete_FalsePosition, 1 },
	 { "new_FalsePosition", _wrap_new_FalsePosition, 1 },
	 { "delete_Brent", _wrap_delete_Brent, 1 },
	 { "new_Brent", _wrap_new_Brent, 1 },
	 { "delete_Bisection", _wrap_delete_Bisection, 1 },
	 { "new_Bisection", _wrap_new_Bisection, 1 },
	 { "Solver1D_pyBracketedSolve", _wrap_Solver1D_pyBracketedSolve, 1 },
	 { "Solver1D_pySolve", _wrap_Solver1D_pySolve, 1 },
	 { "Solver1D_setMaxEvaluations", _wrap_Solver1D_setMaxEvaluations, 1 },
	 { "Solver1D_bracketedSolve", _wrap_Solver1D_bracketedSolve, 1 },
	 { "Solver1D_solve", _wrap_Solver1D_solve, 1 },
	 { "ObjectiveFunction_derivative", _wrap_ObjectiveFunction_derivative, 1 },
	 { "ObjectiveFunction_value", _wrap_ObjectiveFunction_value, 1 },
	 { "RiskTool_addWeightedSequence", _wrap_RiskTool_addWeightedSequence, 1 },
	 { "RiskTool_addSequence", _wrap_RiskTool_addSequence, 1 },
	 { "RiskTool_reset", _wrap_RiskTool_reset, 1 },
	 { "RiskTool_add", _wrap_RiskTool_add, 1 },
	 { "RiskTool_averageShortfall", _wrap_RiskTool_averageShortfall, 1 },
	 { "RiskTool_shortfall", _wrap_RiskTool_shortfall, 1 },
	 { "RiskTool_valueAtRisk", _wrap_RiskTool_valueAtRisk, 1 },
	 { "RiskTool_max", _wrap_RiskTool_max, 1 },
	 { "RiskTool_min", _wrap_RiskTool_min, 1 },
	 { "RiskTool_kurtosis", _wrap_RiskTool_kurtosis, 1 },
	 { "RiskTool_skewness", _wrap_RiskTool_skewness, 1 },
	 { "RiskTool_errorEstimate", _wrap_RiskTool_errorEstimate, 1 },
	 { "RiskTool_standardDeviation", _wrap_RiskTool_standardDeviation, 1 },
	 { "RiskTool_variance", _wrap_RiskTool_variance, 1 },
	 { "RiskTool_mean", _wrap_RiskTool_mean, 1 },
	 { "RiskTool_weightSum", _wrap_RiskTool_weightSum, 1 },
	 { "RiskTool_samples", _wrap_RiskTool_samples, 1 },
	 { "delete_RiskTool", _wrap_delete_RiskTool, 1 },
	 { "new_RiskTool", _wrap_new_RiskTool, 1 },
	 { "GaussianRandomGenerator_weight", _wrap_GaussianRandomGenerator_weight, 1 },
	 { "GaussianRandomGenerator_next", _wrap_GaussianRandomGenerator_next, 1 },
	 { "delete_GaussianRandomGenerator", _wrap_delete_GaussianRandomGenerator, 1 },
	 { "new_GaussianRandomGenerator", _wrap_new_GaussianRandomGenerator, 1 },
	 { "UniformRandomGenerator_weight", _wrap_UniformRandomGenerator_weight, 1 },
	 { "UniformRandomGenerator_next", _wrap_UniformRandomGenerator_next, 1 },
	 { "delete_UniformRandomGenerator", _wrap_delete_UniformRandomGenerator, 1 },
	 { "new_UniformRandomGenerator", _wrap_new_UniformRandomGenerator, 1 },
	 { "DividendEuropeanOption_impliedVolatility", _wrap_DividendEuropeanOption_impliedVolatility, 1 },
	 { "DividendEuropeanOption_rho", _wrap_DividendEuropeanOption_rho, 1 },
	 { "DividendEuropeanOption_vega", _wrap_DividendEuropeanOption_vega, 1 },
	 { "DividendEuropeanOption_theta", _wrap_DividendEuropeanOption_theta, 1 },
	 { "DividendEuropeanOption_gamma", _wrap_DividendEuropeanOption_gamma, 1 },
	 { "DividendEuropeanOption_delta", _wrap_DividendEuropeanOption_delta, 1 },
	 { "DividendEuropeanOption_value", _wrap_DividendEuropeanOption_value, 1 },
	 { "delete_DividendEuropeanOption", _wrap_delete_DividendEuropeanOption, 1 },
	 { "new_DividendEuropeanOption", _wrap_new_DividendEuropeanOption, 1 },
	 { "DividendAmericanOption_impliedVolatility", _wrap_DividendAmericanOption_impliedVolatility, 1 },
	 { "DividendAmericanOption_rho", _wrap_DividendAmericanOption_rho, 1 },
	 { "DividendAmericanOption_vega", _wrap_DividendAmericanOption_vega, 1 },
	 { "DividendAmericanOption_theta", _wrap_DividendAmericanOption_theta, 1 },
	 { "DividendAmericanOption_gamma", _wrap_DividendAmericanOption_gamma, 1 },
	 { "DividendAmericanOption_delta", _wrap_DividendAmericanOption_delta, 1 },
	 { "DividendAmericanOption_value", _wrap_DividendAmericanOption_value, 1 },
	 { "delete_DividendAmericanOption", _wrap_delete_DividendAmericanOption, 1 },
	 { "new_DividendAmericanOption", _wrap_new_DividendAmericanOption, 1 },
	 { "BSMAmericanOption_impliedVolatility", _wrap_BSMAmericanOption_impliedVolatility, 1 },
	 { "BSMAmericanOption_rho", _wrap_BSMAmericanOption_rho, 1 },
	 { "BSMAmericanOption_vega", _wrap_BSMAmericanOption_vega, 1 },
	 { "BSMAmericanOption_theta", _wrap_BSMAmericanOption_theta, 1 },
	 { "BSMAmericanOption_gamma", _wrap_BSMAmericanOption_gamma, 1 },
	 { "BSMAmericanOption_delta", _wrap_BSMAmericanOption_delta, 1 },
	 { "BSMAmericanOption_value", _wrap_BSMAmericanOption_value, 1 },
	 { "BSMAmericanOption_setRiskFreeRate", _wrap_BSMAmericanOption_setRiskFreeRate, 1 },
	 { "BSMAmericanOption_setVolatility", _wrap_BSMAmericanOption_setVolatility, 1 },
	 { "delete_BSMAmericanOption", _wrap_delete_BSMAmericanOption, 1 },
	 { "new_BSMAmericanOption", _wrap_new_BSMAmericanOption, 1 },
	 { "BSMEuropeanOption_impliedVolatility", _wrap_BSMEuropeanOption_impliedVolatility, 1 },
	 { "BSMEuropeanOption_rho", _wrap_BSMEuropeanOption_rho, 1 },
	 { "BSMEuropeanOption_vega", _wrap_BSMEuropeanOption_vega, 1 },
	 { "BSMEuropeanOption_theta", _wrap_BSMEuropeanOption_theta, 1 },
	 { "BSMEuropeanOption_gamma", _wrap_BSMEuropeanOption_gamma, 1 },
	 { "BSMEuropeanOption_delta", _wrap_BSMEuropeanOption_delta, 1 },
	 { "BSMEuropeanOption_value", _wrap_BSMEuropeanOption_value, 1 },
	 { "BSMEuropeanOption_setRiskFreeRate", _wrap_BSMEuropeanOption_setRiskFreeRate, 1 },
	 { "BSMEuropeanOption_setVolatility", _wrap_BSMEuropeanOption_setVolatility, 1 },
	 { "delete_BSMEuropeanOption", _wrap_delete_BSMEuropeanOption, 1 },
	 { "new_BSMEuropeanOption", _wrap_new_BSMEuropeanOption, 1 },
	 { "delete_DPlusDMinus", _wrap_delete_DPlusDMinus, 1 },
	 { "new_DPlusDMinus", _wrap_new_DPlusDMinus, 1 },
	 { "delete_DZero", _wrap_delete_DZero, 1 },
	 { "new_DZero", _wrap_new_DZero, 1 },
	 { "delete_DMinus", _wrap_delete_DMinus, 1 },
	 { "new_DMinus", _wrap_new_DMinus, 1 },
	 { "delete_DPlus", _wrap_delete_DPlus, 1 },
	 { "new_DPlus", _wrap_new_DPlus, 1 },
	 { "TridiagonalOperator_setLastRow", _wrap_TridiagonalOperator_setLastRow, 1 },
	 { "TridiagonalOperator_setMidRows", _wrap_TridiagonalOperator_setMidRows, 1 },
	 { "TridiagonalOperator_setMidRow", _wrap_TridiagonalOperator_setMidRow, 1 },
	 { "TridiagonalOperator_setFirstRow", _wrap_TridiagonalOperator_setFirstRow, 1 },
	 { "TridiagonalOperator_setHigherBC", _wrap_TridiagonalOperator_setHigherBC, 1 },
	 { "TridiagonalOperator_setLowerBC", _wrap_TridiagonalOperator_setLowerBC, 1 },
	 { "TridiagonalOperator_size", _wrap_TridiagonalOperator_size, 1 },
	 { "TridiagonalOperator_applyTo", _wrap_TridiagonalOperator_applyTo, 1 },
	 { "TridiagonalOperator_solveFor", _wrap_TridiagonalOperator_solveFor, 1 },
	 { "delete_TridiagonalOperator", _wrap_delete_TridiagonalOperator, 1 },
	 { "new_TridiagonalOperator", _wrap_new_TridiagonalOperator, 1 },
	 { "McAsianPricer_errorEstimate", _wrap_McAsianPricer_errorEstimate, 1 },
	 { "McAsianPricer_value", _wrap_McAsianPricer_value, 1 },
	 { "new_McAsianPricer", _wrap_new_McAsianPricer, 1 },
	 { "GeometricAsianOption_value", _wrap_GeometricAsianOption_value, 1 },
	 { "new_GeometricAsianOption", _wrap_new_GeometricAsianOption, 1 },
	 { "McEuropeanPricer_errorEstimate", _wrap_McEuropeanPricer_errorEstimate, 1 },
	 { "McEuropeanPricer_value", _wrap_McEuropeanPricer_value, 1 },
	 { "new_McEuropeanPricer", _wrap_new_McEuropeanPricer, 1 },
	 { "StandardPathGenerator_weight", _wrap_StandardPathGenerator_weight, 1 },
	 { "StandardPathGenerator_next", _wrap_StandardPathGenerator_next, 1 },
	 { "new_StandardPathGenerator", _wrap_new_StandardPathGenerator, 1 },
	 { "Interpolation___nonzero__", _wrap_Interpolation___nonzero__, 1 },
	 { "Interpolation___call__", _wrap_Interpolation___call__, 1 },
	 { "delete_Interpolation", _wrap_delete_Interpolation, 1 },
	 { "Instrument___nonzero__", _wrap_Instrument___nonzero__, 1 },
	 { "Instrument___cmp__", _wrap_Instrument___cmp__, 1 },
	 { "Instrument___repr__", _wrap_Instrument___repr__, 1 },
	 { "Instrument___str__", _wrap_Instrument___str__, 1 },
	 { "Instrument_price", _wrap_Instrument_price, 1 },
	 { "Instrument_NPV", _wrap_Instrument_NPV, 1 },
	 { "Instrument_termStructure", _wrap_Instrument_termStructure, 1 },
	 { "Instrument_description", _wrap_Instrument_description, 1 },
	 { "Instrument_isinCode", _wrap_Instrument_isinCode, 1 },
	 { "Instrument_setTermStructure", _wrap_Instrument_setTermStructure, 1 },
	 { "Instrument_setPrice", _wrap_Instrument_setPrice, 1 },
	 { "delete_Instrument", _wrap_delete_Instrument, 1 },
	 { "Deposit_dayCounter", _wrap_Deposit_dayCounter, 1 },
	 { "Deposit_rate", _wrap_Deposit_rate, 1 },
	 { "Deposit_maturity", _wrap_Deposit_maturity, 1 },
	 { "delete_Deposit", _wrap_delete_Deposit, 1 },
	 { "new_Deposit", _wrap_new_Deposit, 1 },
	 { "TermStructure___nonzero__", _wrap_TermStructure___nonzero__, 1 },
	 { "TermStructure_forward", _wrap_TermStructure_forward, 1 },
	 { "TermStructure_discount", _wrap_TermStructure_discount, 1 },
	 { "TermStructure_zeroYield", _wrap_TermStructure_zeroYield, 1 },
	 { "TermStructure_minDate", _wrap_TermStructure_minDate, 1 },
	 { "TermStructure_maxDate", _wrap_TermStructure_maxDate, 1 },
	 { "TermStructure_calendar", _wrap_TermStructure_calendar, 1 },
	 { "TermStructure_settlementDate", _wrap_TermStructure_settlementDate, 1 },
	 { "TermStructure_todaysDate", _wrap_TermStructure_todaysDate, 1 },
	 { "TermStructure_currency", _wrap_TermStructure_currency, 1 },
	 { "TermStructure_clone", _wrap_TermStructure_clone, 1 },
	 { "delete_TermStructure", _wrap_delete_TermStructure, 1 },
	 { "History___repr__", _wrap_History___repr__, 1 },
	 { "History___str__", _wrap_History___str__, 1 },
	 { "History___getitem__", _wrap_History___getitem__, 1 },
	 { "History_valid_data_iterator", _wrap_History_valid_data_iterator, 1 },
	 { "History_vdend", _wrap_History_vdend, 1 },
	 { "History_vdbegin", _wrap_History_vdbegin, 1 },
	 { "History_data_iterator", _wrap_History_data_iterator, 1 },
	 { "History_dend", _wrap_History_dend, 1 },
	 { "History_dbegin", _wrap_History_dbegin, 1 },
	 { "History_valid_iterator", _wrap_History_valid_iterator, 1 },
	 { "History_vend", _wrap_History_vend, 1 },
	 { "History_vbegin", _wrap_History_vbegin, 1 },
	 { "History_iterator", _wrap_History_iterator, 1 },
	 { "History_end", _wrap_History_end, 1 },
	 { "History_begin", _wrap_History_begin, 1 },
	 { "History_size", _wrap_History_size, 1 },
	 { "History_lastDate", _wrap_History_lastDate, 1 },
	 { "History_firstDate", _wrap_History_firstDate, 1 },
	 { "delete_History", _wrap_delete_History, 1 },
	 { "new_History", _wrap_new_History, 1 },
	 { "HistoryValidDataIterator___str__", _wrap_HistoryValidDataIterator___str__, 1 },
	 { "HistoryValidDataIterator___cmp__", _wrap_HistoryValidDataIterator___cmp__, 1 },
	 { "HistoryValidDataIterator_advance", _wrap_HistoryValidDataIterator_advance, 1 },
	 { "HistoryValidDataIterator___float__", _wrap_HistoryValidDataIterator___float__, 1 },
	 { "delete_HistoryValidDataIterator", _wrap_delete_HistoryValidDataIterator, 1 },
	 { "HistoryDataIterator___str__", _wrap_HistoryDataIterator___str__, 1 },
	 { "HistoryDataIterator___cmp__", _wrap_HistoryDataIterator___cmp__, 1 },
	 { "HistoryDataIterator_advance", _wrap_HistoryDataIterator_advance, 1 },
	 { "HistoryDataIterator___float__", _wrap_HistoryDataIterator___float__, 1 },
	 { "delete_HistoryDataIterator", _wrap_delete_HistoryDataIterator, 1 },
	 { "HistoryValidIterator___str__", _wrap_HistoryValidIterator___str__, 1 },
	 { "HistoryValidIterator___cmp__", _wrap_HistoryValidIterator___cmp__, 1 },
	 { "HistoryValidIterator_advance", _wrap_HistoryValidIterator_advance, 1 },
	 { "HistoryValidIterator_value", _wrap_HistoryValidIterator_value, 1 },
	 { "HistoryValidIterator_date", _wrap_HistoryValidIterator_date, 1 },
	 { "delete_HistoryValidIterator", _wrap_delete_HistoryValidIterator, 1 },
	 { "HistoryIterator___str__", _wrap_HistoryIterator___str__, 1 },
	 { "HistoryIterator___cmp__", _wrap_HistoryIterator___cmp__, 1 },
	 { "HistoryIterator_advance", _wrap_HistoryIterator_advance, 1 },
	 { "HistoryIterator_value", _wrap_HistoryIterator_value, 1 },
	 { "HistoryIterator_date", _wrap_HistoryIterator_date, 1 },
	 { "delete_HistoryIterator", _wrap_delete_HistoryIterator, 1 },
	 { "ArrayLexicographicalViewColumn___setitem__", _wrap_ArrayLexicographicalViewColumn___setitem__, 1 },
	 { "ArrayLexicographicalViewColumn___getitem__", _wrap_ArrayLexicographicalViewColumn___getitem__, 1 },
	 { "delete_ArrayLexicographicalViewColumn", _wrap_delete_ArrayLexicographicalViewColumn, 1 },
	 { "ArrayLexicographicalView___str__", _wrap_ArrayLexicographicalView___str__, 1 },
	 { "ArrayLexicographicalView___getitem__", _wrap_ArrayLexicographicalView___getitem__, 1 },
	 { "ArrayLexicographicalView_ySize", _wrap_ArrayLexicographicalView_ySize, 1 },
	 { "ArrayLexicographicalView_xSize", _wrap_ArrayLexicographicalView_xSize, 1 },
	 { "delete_ArrayLexicographicalView", _wrap_delete_ArrayLexicographicalView, 1 },
	 { "Array___str__", _wrap_Array___str__, 1 },
	 { "Array___setitem__", _wrap_Array___setitem__, 1 },
	 { "Array___getitem__", _wrap_Array___getitem__, 1 },
	 { "Array_size", _wrap_Array_size, 1 },
	 { "delete_Array", _wrap_delete_Array, 1 },
	 { "new_Array", _wrap_new_Array, 1 },
	 { "InvCumulativeNormalDistribution___call__", _wrap_InvCumulativeNormalDistribution___call__, 1 },
	 { "delete_InvCumulativeNormalDistribution", _wrap_delete_InvCumulativeNormalDistribution, 1 },
	 { "new_InvCumulativeNormalDistribution", _wrap_new_InvCumulativeNormalDistribution, 1 },
	 { "CumulativeNormalDistribution___call__", _wrap_CumulativeNormalDistribution___call__, 1 },
	 { "CumulativeNormalDistribution_derivative", _wrap_CumulativeNormalDistribution_derivative, 1 },
	 { "delete_CumulativeNormalDistribution", _wrap_delete_CumulativeNormalDistribution, 1 },
	 { "new_CumulativeNormalDistribution", _wrap_new_CumulativeNormalDistribution, 1 },
	 { "NormalDistribution___call__", _wrap_NormalDistribution___call__, 1 },
	 { "NormalDistribution_derivative", _wrap_NormalDistribution_derivative, 1 },
	 { "delete_NormalDistribution", _wrap_delete_NormalDistribution, 1 },
	 { "new_NormalDistribution", _wrap_new_NormalDistribution, 1 },
	 { "DayCounter___nonzero__", _wrap_DayCounter___nonzero__, 1 },
	 { "DayCounter___cmp__", _wrap_DayCounter___cmp__, 1 },
	 { "DayCounter___repr__", _wrap_DayCounter___repr__, 1 },
	 { "DayCounter___str__", _wrap_DayCounter___str__, 1 },
	 { "DayCounter_yearFraction", _wrap_DayCounter_yearFraction, 1 },
	 { "DayCounter_dayCount", _wrap_DayCounter_dayCount, 1 },
	 { "delete_DayCounter", _wrap_delete_DayCounter, 1 },
	 { "Currency___nonzero__", _wrap_Currency___nonzero__, 1 },
	 { "Currency___cmp__", _wrap_Currency___cmp__, 1 },
	 { "Currency___repr__", _wrap_Currency___repr__, 1 },
	 { "Currency___str__", _wrap_Currency___str__, 1 },
	 { "Currency_settlementDate", _wrap_Currency_settlementDate, 1 },
	 { "Currency_settlementDays", _wrap_Currency_settlementDays, 1 },
	 { "Currency_settlementCalendar", _wrap_Currency_settlementCalendar, 1 },
	 { "delete_Currency", _wrap_delete_Currency, 1 },
	 { "Calendar___nonzero__", _wrap_Calendar___nonzero__, 1 },
	 { "Calendar___cmp__", _wrap_Calendar___cmp__, 1 },
	 { "Calendar___repr__", _wrap_Calendar___repr__, 1 },
	 { "Calendar___str__", _wrap_Calendar___str__, 1 },
	 { "Calendar_advance", _wrap_Calendar_advance, 1 },
	 { "Calendar_roll", _wrap_Calendar_roll, 1 },
	 { "Calendar_isHoliday", _wrap_Calendar_isHoliday, 1 },
	 { "Calendar_isBusinessDay", _wrap_Calendar_isBusinessDay, 1 },
	 { "delete_Calendar", _wrap_delete_Calendar, 1 },
	 { "Date___repr__", _wrap_Date___repr__, 1 },
	 { "Date___str__", _wrap_Date___str__, 1 },
	 { "Date___cmp__", _wrap_Date___cmp__, 1 },
	 { "Date___sub__", _wrap_Date___sub__, 1 },
	 { "Date___add__", _wrap_Date___add__, 1 },
	 { "Date_weekdayNumber", _wrap_Date_weekdayNumber, 1 },
	 { "Date_monthNumber", _wrap_Date_monthNumber, 1 },
	 { "Date_maxDate", _wrap_Date_maxDate, 1 },
	 { "Date_minDate", _wrap_Date_minDate, 1 },
	 { "Date_isLeap", _wrap_Date_isLeap, 1 },
	 { "Date_plus", _wrap_Date_plus, 1 },
	 { "Date_plusYears", _wrap_Date_plusYears, 1 },
	 { "Date_plusMonths", _wrap_Date_plusMonths, 1 },
	 { "Date_plusWeeks", _wrap_Date_plusWeeks, 1 },
	 { "Date_plusDays", _wrap_Date_plusDays, 1 },
	 { "Date_serialNumber", _wrap_Date_serialNumber, 1 },
	 { "Date_year", _wrap_Date_year, 1 },
	 { "Date_month", _wrap_Date_month, 1 },
	 { "Date_dayOfYear", _wrap_Date_dayOfYear, 1 },
	 { "Date_dayOfMonth", _wrap_Date_dayOfMonth, 1 },
	 { "Date_weekday", _wrap_Date_weekday, 1 },
	 { "delete_Date", _wrap_delete_Date, 1 },
	 { "new_Date", _wrap_new_Date, 1 },
	 { "BoundaryCondition_value", _wrap_BoundaryCondition_value, 1 },
	 { "BoundaryCondition_type", _wrap_BoundaryCondition_type, 1 },
	 { "delete_BoundaryCondition", _wrap_delete_BoundaryCondition, 1 },
	 { "new_BoundaryCondition", _wrap_new_BoundaryCondition, 1 },
	 { "CubicSpline", _wrap_CubicSpline, 1 },
	 { "LinearInterpolation", _wrap_LinearInterpolation, 1 },
	 { "Stock", _wrap_Stock, 1 },
	 { "PiecewiseConstantForwards", _wrap_PiecewiseConstantForwards, 1 },
	 { "FlatForward", _wrap_FlatForward, 1 },
	 { "SpreadedTermStructure", _wrap_SpreadedTermStructure, 1 },
	 { "ImpliedTermStructure", _wrap_ImpliedTermStructure, 1 },
	 { "LexicographicalView", _wrap_LexicographicalView, 1 },
	 { "Thirty360Italian", _wrap_Thirty360Italian, 1 },
	 { "Thirty360European", _wrap_Thirty360European, 1 },
	 { "Thirty360", _wrap_Thirty360, 1 },
	 { "Actual365", _wrap_Actual365, 1 },
	 { "Actual360", _wrap_Actual360, 1 },
	 { "SEK", _wrap_SEK, 1 },
	 { "JPY", _wrap_JPY, 1 },
	 { "DKK", _wrap_DKK, 1 },
	 { "CHF", _wrap_CHF, 1 },
	 { "CAD", _wrap_CAD, 1 },
	 { "AUD", _wrap_AUD, 1 },
	 { "ITL", _wrap_ITL, 1 },
	 { "DEM", _wrap_DEM, 1 },
	 { "GBP", _wrap_GBP, 1 },
	 { "USD", _wrap_USD, 1 },
	 { "EUR", _wrap_EUR, 1 },
	 { "Zurich", _wrap_Zurich, 1 },
	 { "Milan", _wrap_Milan, 1 },
	 { "Frankfurt", _wrap_Frankfurt, 1 },
	 { "London", _wrap_London, 1 },
	 { "NewYork", _wrap_NewYork, 1 },
	 { "TARGET", _wrap_TARGET, 1 },
	 { "DateFromSerialNumber", _wrap_DateFromSerialNumber, 1 },
	 { NULL, NULL }
};
static PyObject *SWIG_globals;
#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT(void,initQuantLibc)() {
	 PyObject *m, *d;
	 SWIG_globals = SWIG_newvarlink();
	 m = Py_InitModule("QuantLibc", QuantLibcMethods);
	 d = PyModule_GetDict(m);
/*
 * These are the pointer type-equivalency mappings. 
 * (Used by the SWIG pointer type-checker).
 */
	 SWIG_RegisterMapping("_class_McEuropeanPricer","_McEuropeanPricer",0);
	 SWIG_RegisterMapping("_GeometricAsianOption","_class_GeometricAsianOption",0);
	 SWIG_RegisterMapping("_DividendEuropeanOption","_class_DividendEuropeanOption",0);
	 SWIG_RegisterMapping("_signed_long","_long",0);
	 SWIG_RegisterMapping("_NormalDistribution","_class_NormalDistribution",0);
	 SWIG_RegisterMapping("_InvCumulativeNormalDistribution","_class_InvCumulativeNormalDistribution",0);
	 SWIG_RegisterMapping("_McAsianPricer","_class_McAsianPricer",0);
	 SWIG_RegisterMapping("_class_Newton","_Newton",0);
	 SWIG_RegisterMapping("_Array","_class_Array",0);
	 SWIG_RegisterMapping("_class_BSMEuropeanOption","_BSMEuropeanOption",0);
	 SWIG_RegisterMapping("_GaussianRandomGenerator","_class_GaussianRandomGenerator",0);
	 SWIG_RegisterMapping("_double","_DiscountFactor",0);
	 SWIG_RegisterMapping("_double","_Spread",0);
	 SWIG_RegisterMapping("_double","_Rate",0);
	 SWIG_RegisterMapping("_double","_Time",0);
	 SWIG_RegisterMapping("_Year","_int",0);
	 SWIG_RegisterMapping("_Year","_signed_int",0);
	 SWIG_RegisterMapping("_Year","_unsigned_int",0);
	 SWIG_RegisterMapping("_Year","_Day",0);
	 SWIG_RegisterMapping("_History","_class_History",0);
	 SWIG_RegisterMapping("_class_DPlus","_DPlus",0);
	 SWIG_RegisterMapping("_UniformRandomGenerator","_class_UniformRandomGenerator",0);
	 SWIG_RegisterMapping("_class_ObjectiveFunction","_ObjectiveFunction",0);
	 SWIG_RegisterMapping("_long","_unsigned_long",0);
	 SWIG_RegisterMapping("_long","_signed_long",0);
	 SWIG_RegisterMapping("_class_NormalDistribution","_NormalDistribution",0);
	 SWIG_RegisterMapping("_BoundaryCondition","_class_BoundaryCondition",0);
	 SWIG_RegisterMapping("_InstrumentHandle","_class_InstrumentHandle",0);
	 SWIG_RegisterMapping("_CumulativeNormalDistribution","_class_CumulativeNormalDistribution",0);
	 SWIG_RegisterMapping("_DMinus","_class_DMinus",0);
	 SWIG_RegisterMapping("_class_NewtonSafe","_NewtonSafe",0);
	 SWIG_RegisterMapping("_DayCounterHandle","_class_DayCounterHandle",0);
	 SWIG_RegisterMapping("_HistoryValidDataIterator","_class_HistoryValidDataIterator",0);
	 SWIG_RegisterMapping("_InterpolationHandle","_class_InterpolationHandle",0);
	 SWIG_RegisterMapping("_class_DividendAmericanOption","_DividendAmericanOption",0);
	 SWIG_RegisterMapping("_Ridder","_class_Ridder",0);
	 SWIG_RegisterMapping("_Brent","_class_Brent",0);
	 SWIG_RegisterMapping("_RiskTool","_class_RiskTool",0);
	 SWIG_RegisterMapping("_class_Date","_Date",0);
	 SWIG_RegisterMapping("_class_DividendEuropeanOption","_DividendEuropeanOption",0);
	 SWIG_RegisterMapping("_class_InvCumulativeNormalDistribution","_InvCumulativeNormalDistribution",0);
	 SWIG_RegisterMapping("_class_McAsianPricer","_McAsianPricer",0);
	 SWIG_RegisterMapping("_class_DZero","_DZero",0);
	 SWIG_RegisterMapping("_HistoryDataIterator","_class_HistoryDataIterator",0);
	 SWIG_RegisterMapping("_class_DMinus","_DMinus",0);
	 SWIG_RegisterMapping("_class_HistoryValidDataIterator","_HistoryValidDataIterator",0);
	 SWIG_RegisterMapping("_class_History","_History",0);
	 SWIG_RegisterMapping("_class_Solver1D","_class_Secant",SwigSecantToSolver1D);
	 SWIG_RegisterMapping("_class_Solver1D","_Secant",SwigSecantToSolver1D);
	 SWIG_RegisterMapping("_class_Solver1D","_class_Ridder",SwigRidderToSolver1D);
	 SWIG_RegisterMapping("_class_Solver1D","_Ridder",SwigRidderToSolver1D);
	 SWIG_RegisterMapping("_class_Solver1D","_class_NewtonSafe",SwigNewtonSafeToSolver1D);
	 SWIG_RegisterMapping("_class_Solver1D","_NewtonSafe",SwigNewtonSafeToSolver1D);
	 SWIG_RegisterMapping("_class_Solver1D","_class_Newton",SwigNewtonToSolver1D);
	 SWIG_RegisterMapping("_class_Solver1D","_Newton",SwigNewtonToSolver1D);
	 SWIG_RegisterMapping("_class_Solver1D","_class_FalsePosition",SwigFalsePositionToSolver1D);
	 SWIG_RegisterMapping("_class_Solver1D","_FalsePosition",SwigFalsePositionToSolver1D);
	 SWIG_RegisterMapping("_class_Solver1D","_class_Brent",SwigBrentToSolver1D);
	 SWIG_RegisterMapping("_class_Solver1D","_Brent",SwigBrentToSolver1D);
	 SWIG_RegisterMapping("_class_Solver1D","_class_Bisection",SwigBisectionToSolver1D);
	 SWIG_RegisterMapping("_class_Solver1D","_Bisection",SwigBisectionToSolver1D);
	 SWIG_RegisterMapping("_class_Solver1D","_Solver1D",0);
	 SWIG_RegisterMapping("_class_CurrencyHandle","_CurrencyHandle",0);
	 SWIG_RegisterMapping("_TridiagonalOperator","_class_DPlusDMinus",SwigDPlusDMinusToTridiagonalOperator);
	 SWIG_RegisterMapping("_TridiagonalOperator","_DPlusDMinus",SwigDPlusDMinusToTridiagonalOperator);
	 SWIG_RegisterMapping("_TridiagonalOperator","_class_DZero",SwigDZeroToTridiagonalOperator);
	 SWIG_RegisterMapping("_TridiagonalOperator","_DZero",SwigDZeroToTridiagonalOperator);
	 SWIG_RegisterMapping("_TridiagonalOperator","_class_DMinus",SwigDMinusToTridiagonalOperator);
	 SWIG_RegisterMapping("_TridiagonalOperator","_DMinus",SwigDMinusToTridiagonalOperator);
	 SWIG_RegisterMapping("_TridiagonalOperator","_class_DPlus",SwigDPlusToTridiagonalOperator);
	 SWIG_RegisterMapping("_TridiagonalOperator","_DPlus",SwigDPlusToTridiagonalOperator);
	 SWIG_RegisterMapping("_TridiagonalOperator","_class_TridiagonalOperator",0);
	 SWIG_RegisterMapping("_class_UniformRandomGenerator","_UniformRandomGenerator",0);
	 SWIG_RegisterMapping("_class_Ridder","_Ridder",0);
	 SWIG_RegisterMapping("_BSMAmericanOption","_class_BSMAmericanOption",0);
	 SWIG_RegisterMapping("_HistoryValidIterator","_class_HistoryValidIterator",0);
	 SWIG_RegisterMapping("_Spread","_DiscountFactor",0);
	 SWIG_RegisterMapping("_Spread","_double",0);
	 SWIG_RegisterMapping("_Spread","_Time",0);
	 SWIG_RegisterMapping("_Spread","_Rate",0);
	 SWIG_RegisterMapping("_ArrayLexicographicalView","_class_ArrayLexicographicalView",0);
	 SWIG_RegisterMapping("_Secant","_class_Secant",0);
	 SWIG_RegisterMapping("_unsigned_long","_long",0);
	 SWIG_RegisterMapping("_class_InstrumentHandle","_InstrumentHandle",0);
	 SWIG_RegisterMapping("_BSMEuropeanOption","_class_BSMEuropeanOption",0);
	 SWIG_RegisterMapping("_Bisection","_class_Bisection",0);
	 SWIG_RegisterMapping("_class_CumulativeNormalDistribution","_CumulativeNormalDistribution",0);
	 SWIG_RegisterMapping("_class_DPlusDMinus","_DPlusDMinus",0);
	 SWIG_RegisterMapping("_class_DayCounterHandle","_DayCounterHandle",0);
	 SWIG_RegisterMapping("_class_InterpolationHandle","_InterpolationHandle",0);
	 SWIG_RegisterMapping("_signed_int","_Year",0);
	 SWIG_RegisterMapping("_signed_int","_Day",0);
	 SWIG_RegisterMapping("_signed_int","_int",0);
	 SWIG_RegisterMapping("_DPlus","_class_DPlus",0);
	 SWIG_RegisterMapping("_Statistics","_class_Statistics",0);
	 SWIG_RegisterMapping("_ObjectiveFunction","_class_ObjectiveFunction",0);
	 SWIG_RegisterMapping("_unsigned_short","_short",0);
	 SWIG_RegisterMapping("_class_CalendarHandle","_CalendarHandle",0);
	 SWIG_RegisterMapping("_class_ArrayLexicographicalView","_ArrayLexicographicalView",0);
	 SWIG_RegisterMapping("_class_GeometricAsianOption","_GeometricAsianOption",0);
	 SWIG_RegisterMapping("_class_Secant","_Secant",0);
	 SWIG_RegisterMapping("_class_Array","_Array",0);
	 SWIG_RegisterMapping("_class_GaussianRandomGenerator","_GaussianRandomGenerator",0);
	 SWIG_RegisterMapping("_class_Bisection","_Bisection",0);
	 SWIG_RegisterMapping("_Day","_Year",0);
	 SWIG_RegisterMapping("_Day","_int",0);
	 SWIG_RegisterMapping("_Day","_signed_int",0);
	 SWIG_RegisterMapping("_Day","_unsigned_int",0);
	 SWIG_RegisterMapping("_class_HistoryDataIterator","_HistoryDataIterator",0);
	 SWIG_RegisterMapping("_signed_short","_short",0);
	 SWIG_RegisterMapping("_Deposit","_class_Deposit",0);
	 SWIG_RegisterMapping("_unsigned_int","_Year",0);
	 SWIG_RegisterMapping("_unsigned_int","_Day",0);
	 SWIG_RegisterMapping("_unsigned_int","_int",0);
	 SWIG_RegisterMapping("_class_TridiagonalOperator","_class_DPlusDMinus",SwigDPlusDMinusToTridiagonalOperator);
	 SWIG_RegisterMapping("_class_TridiagonalOperator","_DPlusDMinus",SwigDPlusDMinusToTridiagonalOperator);
	 SWIG_RegisterMapping("_class_TridiagonalOperator","_class_DZero",SwigDZeroToTridiagonalOperator);
	 SWIG_RegisterMapping("_class_TridiagonalOperator","_DZero",SwigDZeroToTridiagonalOperator);
	 SWIG_RegisterMapping("_class_TridiagonalOperator","_class_DMinus",SwigDMinusToTridiagonalOperator);
	 SWIG_RegisterMapping("_class_TridiagonalOperator","_DMinus",SwigDMinusToTridiagonalOperator);
	 SWIG_RegisterMapping("_class_TridiagonalOperator","_class_DPlus",SwigDPlusToTridiagonalOperator);
	 SWIG_RegisterMapping("_class_TridiagonalOperator","_DPlus",SwigDPlusToTridiagonalOperator);
	 SWIG_RegisterMapping("_class_TridiagonalOperator","_TridiagonalOperator",0);
	 SWIG_RegisterMapping("_TermStructureHandle","_class_TermStructureHandle",0);
	 SWIG_RegisterMapping("_short","_unsigned_short",0);
	 SWIG_RegisterMapping("_short","_signed_short",0);
	 SWIG_RegisterMapping("_FalsePosition","_class_FalsePosition",0);
	 SWIG_RegisterMapping("_McEuropeanPricer","_class_McEuropeanPricer",0);
	 SWIG_RegisterMapping("_class_BoundaryCondition","_BoundaryCondition",0);
	 SWIG_RegisterMapping("_int","_Year",0);
	 SWIG_RegisterMapping("_int","_Day",0);
	 SWIG_RegisterMapping("_int","_unsigned_int",0);
	 SWIG_RegisterMapping("_int","_signed_int",0);
	 SWIG_RegisterMapping("_DZero","_class_DZero",0);
	 SWIG_RegisterMapping("_Rate","_DiscountFactor",0);
	 SWIG_RegisterMapping("_Rate","_Spread",0);
	 SWIG_RegisterMapping("_Rate","_double",0);
	 SWIG_RegisterMapping("_Rate","_Time",0);
	 SWIG_RegisterMapping("_Solver1D","_class_Secant",SwigSecantToSolver1D);
	 SWIG_RegisterMapping("_Solver1D","_Secant",SwigSecantToSolver1D);
	 SWIG_RegisterMapping("_Solver1D","_class_Ridder",SwigRidderToSolver1D);
	 SWIG_RegisterMapping("_Solver1D","_Ridder",SwigRidderToSolver1D);
	 SWIG_RegisterMapping("_Solver1D","_class_NewtonSafe",SwigNewtonSafeToSolver1D);
	 SWIG_RegisterMapping("_Solver1D","_NewtonSafe",SwigNewtonSafeToSolver1D);
	 SWIG_RegisterMapping("_Solver1D","_class_Newton",SwigNewtonToSolver1D);
	 SWIG_RegisterMapping("_Solver1D","_Newton",SwigNewtonToSolver1D);
	 SWIG_RegisterMapping("_Solver1D","_class_FalsePosition",SwigFalsePositionToSolver1D);
	 SWIG_RegisterMapping("_Solver1D","_FalsePosition",SwigFalsePositionToSolver1D);
	 SWIG_RegisterMapping("_Solver1D","_class_Brent",SwigBrentToSolver1D);
	 SWIG_RegisterMapping("_Solver1D","_Brent",SwigBrentToSolver1D);
	 SWIG_RegisterMapping("_Solver1D","_class_Bisection",SwigBisectionToSolver1D);
	 SWIG_RegisterMapping("_Solver1D","_Bisection",SwigBisectionToSolver1D);
	 SWIG_RegisterMapping("_Solver1D","_class_Solver1D",0);
	 SWIG_RegisterMapping("_class_Statistics","_Statistics",0);
	 SWIG_RegisterMapping("_CurrencyHandle","_class_CurrencyHandle",0);
	 SWIG_RegisterMapping("_class_Brent","_Brent",0);
	 SWIG_RegisterMapping("_class_RiskTool","_RiskTool",0);
	 SWIG_RegisterMapping("_ArrayLexicographicalViewColumn","_class_ArrayLexicographicalViewColumn",0);
	 SWIG_RegisterMapping("_HistoryIterator","_class_HistoryIterator",0);
	 SWIG_RegisterMapping("_StandardPathGenerator","_class_StandardPathGenerator",0);
	 SWIG_RegisterMapping("_DiscountFactor","_double",0);
	 SWIG_RegisterMapping("_DiscountFactor","_Time",0);
	 SWIG_RegisterMapping("_DiscountFactor","_Rate",0);
	 SWIG_RegisterMapping("_DiscountFactor","_Spread",0);
	 SWIG_RegisterMapping("_Newton","_class_Newton",0);
	 SWIG_RegisterMapping("_DPlusDMinus","_class_DPlusDMinus",0);
	 SWIG_RegisterMapping("_NewtonSafe","_class_NewtonSafe",0);
	 SWIG_RegisterMapping("_class_Deposit","_Deposit",0);
	 SWIG_RegisterMapping("_Time","_DiscountFactor",0);
	 SWIG_RegisterMapping("_Time","_Spread",0);
	 SWIG_RegisterMapping("_Time","_Rate",0);
	 SWIG_RegisterMapping("_Time","_double",0);
	 SWIG_RegisterMapping("_DividendAmericanOption","_class_DividendAmericanOption",0);
	 SWIG_RegisterMapping("_class_TermStructureHandle","_TermStructureHandle",0);
	 SWIG_RegisterMapping("_class_BSMAmericanOption","_BSMAmericanOption",0);
	 SWIG_RegisterMapping("_class_HistoryValidIterator","_HistoryValidIterator",0);
	 SWIG_RegisterMapping("_CalendarHandle","_class_CalendarHandle",0);
	 SWIG_RegisterMapping("_Date","_class_Date",0);
	 SWIG_RegisterMapping("_class_ArrayLexicographicalViewColumn","_ArrayLexicographicalViewColumn",0);
	 SWIG_RegisterMapping("_class_HistoryIterator","_HistoryIterator",0);
	 SWIG_RegisterMapping("_class_StandardPathGenerator","_StandardPathGenerator",0);
	 SWIG_RegisterMapping("_class_FalsePosition","_FalsePosition",0);
}
