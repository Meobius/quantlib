dnl
dnl $Id$
dnl
dnl This is QuantLib's configure.in
dnl Process this file with autoconf to produce a configure script.
dnl

AC_INIT(Include/ql/qldefines.hpp)

AM_CONFIG_HEADER(Include/ql/config.hpp)
AM_INIT_AUTOMAKE(QuantLib, 0.1.9)

dnl Check for programs

CXXFLAGS=-Wall
AC_PROG_INSTALL
AC_PROG_CC
AC_PROG_CXX
AC_LANG_CPLUSPLUS
AM_PROG_LIBTOOL
AC_PATH_PROG(SED, sed, notfound)
AM_CONDITIONAL(SED_FOUND, test x$SED != xnotfound)
AC_PATH_PROG(DOXYGEN, doxygen, notfound)
AM_CONDITIONAL(DOXYGEN_FOUND, test x$DOXYGEN != xnotfound)
AC_PATH_PROG(LATEX, latex, notfound)
AM_CONDITIONAL(LATEX_FOUND, test x$LATEX != xnotfound)
AC_PATH_PROG(PDFLATEX, pdflatex, notfound)
AM_CONDITIONAL(PDFLATEX_FOUND, test x$PDFLATEX != xnotfound)
AC_PATH_PROG(DVIPS, dvips, notfound)
AM_CONDITIONAL(DVIPS_FOUND, test x$DVIPS != xnotfound)

AC_MSG_CHECKING(if C++ compiler supports namespaces (required))
AC_TRY_COMPILE(
[
namespace Foo { struct A {}; }
using namespace Foo;
],[
A a;
],[
ac_namespaces=yes
],[
config_errors=yes
ac_namespaces=no
])
AC_MSG_RESULT([$ac_namespaces])
AC_MSG_CHECKING(if C++ environment has working string class (required))
AC_TRY_LINK(
[
#include <string>
namespace std{}
using namespace std;
  class foo {
  public:
    void f(const string &s);
  };
  void foo::f(const string &s) {
    f(s.c_str());
  }
],[
   foo f1;
   f1.f("test");
],[
  ql_string_ok=yes
],[
  ql_string_ok=no
  config_error=yes
  AC_ERROR(C++ compilers string support does not work)
])
AC_MSG_RESULT([$ql_string_ok])
INCLUDES="-I`pwd`/Include"
AC_SUBST(INCLUDES)
AC_CHECK_HEADERS(math.h cmath ctype.h cctype ctime time.h)
AC_CHECK_HEADERS(limits climits limits.h float.h)

if test $ac_cv_header_cmath = yes ; then
  ql_math=cmath
elif test $ac_cv_header_math_h = yes ; then
  ql_math=math.h
else
  AC_ERROR(Could not find cmath nor math.h)
fi
QL_CHECK_FUNCTION([sqrt],[$ql_math],[2])
QL_CHECK_FUNCTION([fabs],[$ql_math],[2])
QL_CHECK_FUNCTION([exp],[$ql_math],[2])
QL_CHECK_FUNCTION([log],[$ql_math],[2])
QL_CHECK_FUNCTION([sin],[$ql_math],[2])
QL_CHECK_FUNCTION([cos],[$ql_math],[2])
QL_CHECK_FUNCTION([pow],[$ql_math],[2,2])
QL_CHECK_FUNCTION([modf],[$ql_math],[2,&x])

if test $ac_cv_header_cctype = yes ; then
  ql_ctype=cctype
elif test $ac_cv_header_ctype_h = yes ; then
  ql_ctype=ctype.h
else
  AC_ERROR(Could not find cctype nor ctype.h)
fi
QL_CHECK_FUNCTION([toupper],[$ql_ctype],['c'])
QL_CHECK_FUNCTION([strlen],[$ql_ctype],["foo"])
QL_CHECK_FUNCTION([tolower],[$ql_ctype],['c'])

if test $ac_cv_header_ctime = yes ; then
  ql_time=ctime
elif test $ac_cv_header_time_h = yes ; then
  ql_time=time.h
else
  AC_ERROR(Could not find ctime nor time.h)
fi
QL_CHECK_FUNCTION([clock],[$ql_time],[])
QL_CHECK_FUNCTION([time],[$ql_time],[])

QL_CHECK_FUNCTION([max],[algorithm],[1,2])
QL_CHECK_FUNCTION([min],[algorithm],[1,2])

QL_CHECK_TEMPLATE_CLASS([iterator],[std::input_iterator_tag,double],\
    [iterator],[])
QL_CHECK_TEMPLATE_CLASS([iterator_traits],[int*],[iterator],[])


AC_OUTPUT(Makefile \
    Include/Makefile \
    Include/ql/Makefile \
    Include/ql/Calendars/Makefile \
    Include/ql/CashFlows/Makefile \
    Include/ql/DayCounters/Makefile \
    Include/ql/FiniteDifferences/Makefile \
    Include/ql/Indexes/Makefile \
    Include/ql/Instruments/Makefile \
    Include/ql/Math/Makefile \
    Include/ql/MonteCarlo/Makefile \
    Include/ql/Patterns/Makefile \
    Include/ql/Pricers/Makefile \
    Include/ql/Solvers1D/Makefile \
    Include/ql/TermStructures/Makefile \
    Include/ql/Utilities/Makefile \
    Sources/Makefile \
    Sources/Calendars/Makefile \
    Sources/CashFlows/Makefile \
    Sources/DayCounters/Makefile \
    Sources/FiniteDifferences/Makefile \
    Sources/Indexes/Makefile \
    Sources/Instruments/Makefile \
    Sources/Math/Makefile \
    Sources/MonteCarlo/Makefile \
    Sources/Pricers/Makefile \
    Sources/Solvers1D/Makefile \
    Sources/TermStructures/Makefile \
    Docs/Makefile \
    Examples/Makefile \
    Examples/Parities/Makefile \
    Examples/HedgingError/Makefile \
    )

