dnl
dnl $Id$
dnl
dnl This is QuantLib's configure.in
dnl Process this file with autoconf to produce a configure script.
dnl

AC_INIT(Include/qldefines.h)

AM_CONFIG_HEADER(Include/config.h)
AM_INIT_AUTOMAKE(QuantLib, 0.1.1)

dnl Check for programs

AC_PROG_INSTALL
AC_PROG_CC
AC_PROG_CXX
AC_LANG_CPLUSPLUS
AM_PROG_LIBTOOL
AC_PATH_PROG(SED, sed)
AC_PATH_PROG(SWIG, swig, notfound)
AM_CONDITIONAL(SWIG_FOUND, test x$SWIG != xnotfound)
AC_PATH_PROG(PYTHON, python, notfound)
AM_CONDITIONAL(PYTHON_FOUND, test x$PYTHON != xnotfound)
AC_PATH_PROG(RUBY, ruby, notfound)
AM_CONDITIONAL(RUBY_FOUND, test x$RUBY != xnotfound)
AC_PATH_PROG(DOXYGEN, doxygen, notfound)
AM_CONDITIONAL(DOXYGEN_FOUND, test x$DOXYGEN != xnotfound)

dnl Check for Libraries
dnl Testing for Python 1.5
AC_CHECK_LIB(python1.5,PyArg_Parse, 
				[PYLIB=-lpython1.5
				 py15_found=yes]
	) 

dnl Testing for Python 2.0
AC_CHECK_LIB(python2.0,PyArg_Parse, 
				[PYLIB=-lpython2.0
				 py20_found=yes]
	)

AM_CONDITIONAL(python_found,test "$py20_found" = yes)
AM_CONDITIONAL(python_found,test "$py15_found" = yes)
AC_SUBST(PYLIB)

AC_MSG_CHECKING(if C++ compiler supports namespaces (required))
AC_TRY_COMPILE(
[
namespace Foo { struct A {}; }
using namespace Foo;
],[
A a;
],[
ac_namespaces=yes
],[
config_errors=yes
ac_namespaces=no
])
AC_MSG_RESULT([$ac_namespaces])
AC_MSG_CHECKING(if C++ environment has working string class (required))
AC_TRY_LINK(
[
#include <string>
namespace std{}
using namespace std;
  class foo {
  public:
    void f(const string &s);
  };
  void foo::f(const string &s) {
    f(s.c_str());
  }
],[
   foo f1;
   f1.f("test");
],[
  ql_string_ok=yes
],[
  ql_string_ok=no
  config_error=yes 
  AC_ERROR(C++ compilers string support does not work)
])
AC_MSG_RESULT([$ql_string_ok])

AC_CHECK_HEADERS(math.h cmath ctype.h cctype ctime time.h)
AC_CHECK_HEADERS(limits climits limits.h float.h)

if test $ac_cv_header_cmath = yes ; then
  ql_math=cmath
elif test $ac_cv_header_math_h = yes ; then
  ql_math=math.h
else
  AC_ERROR(Could not find cmath nor math.h)
fi
QL_CHECK_FUNCTION([sqrt],[$ql_math],[2])
QL_CHECK_FUNCTION([fabs],[$ql_math],[2])
QL_CHECK_FUNCTION([exp],[$ql_math],[2])
QL_CHECK_FUNCTION([log],[$ql_math],[2])
QL_CHECK_FUNCTION([sin],[$ql_math],[2])
QL_CHECK_FUNCTION([cos],[$ql_math],[2])
QL_CHECK_FUNCTION([pow],[$ql_math],[2,2])
QL_CHECK_FUNCTION([modf],[$ql_math],[2,&x])

if test $ac_cv_header_cctype = yes ; then
  ql_ctype=cctype
elif test $ac_cv_header_ctype_h = yes ; then
  ql_ctype=ctype.h
else
  AC_ERROR(Could not find cctype nor ctype.h)
fi
QL_CHECK_FUNCTION([toupper],[$ql_ctype],['c'])
QL_CHECK_FUNCTION([strlen],[$ql_ctype],["foo"])
QL_CHECK_FUNCTION([tolower],[$ql_ctype],['c'])

if test $ac_cv_header_ctime = yes ; then
  ql_time=ctime
elif test $ac_cv_header_time_h = yes ; then
  ql_time=time.h
else
  AC_ERROR(Could not find ctime nor time.h)
fi
QL_CHECK_FUNCTION([clock],[$ql_time],[])

QL_CHECK_FUNCTION([max],[algorithm],[1,2])
QL_CHECK_FUNCTION([min],[algorithm],[1,2])

QL_CHECK_TEMPLATE_CLASS([iterator],[std::input_iterator_tag,double],\
    [iterator],[])
QL_CHECK_TEMPLATE_CLASS([iterator_traits],[int*],[iterator],[])


AC_OUTPUT(Makefile Sources/Makefile Sources/FiniteDifferences/Makefile \
	Sources/Calendars/Makefile \
	Sources/Solvers1D/Makefile Sources/TermStructures/Makefile \
	Sources/DayCounters/Makefile Sources/Math/Makefile \
	Sources/Pricers/Makefile Include/Makefile \
	Sources/MonteCarlo/Makefile \
	Include/Calendars/Makefile Include/Currencies/Makefile \
	Include/DayCounters/Makefile \
	Include/FiniteDifferences/Makefile Include/Instruments/Makefile \
	Include/Math/Makefile Include/Patterns/Makefile \
	Include/Pricers/Makefile \
	Include/Solvers1D/Makefile Include/TermStructures/Makefile \
	Include/MonteCarlo/Makefile \
	Include/Utilities/Makefile \
	Python/Makefile Python/Tests/Makefile \
	Ruby/Tests/Makefile SWIG/Makefile \
	Docs/Makefile) 
