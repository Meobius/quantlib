*** QuantLib-old/ql/Indexes/xibormanager.hpp	Fri Oct 11 13:20:34 2002
--- QuantLib/ql/Indexes/xibormanager.hpp	Tue Oct 22 11:34:50 2002
***************
*** 46,52 ****
              static bool hasHistory(const std::string& name);
              static std::vector<std::string> histories();
            private:
!             static HistoryMap historyMap_;
          };
  
      }
--- 46,54 ----
              static bool hasHistory(const std::string& name);
              static std::vector<std::string> histories();
            private:
!             static void checkHistoryMap();
!             static bool initialized_;
!             static HistoryMap* historyMap_;
          };
  
      }
*** QuantLib-old/ql/Indexes/xibormanager.cpp	Tue Oct 22 11:26:36 2002
--- QuantLib/ql/Indexes/xibormanager.cpp	Tue Oct 22 11:34:43 2002
***************
*** 30,62 ****
  
      namespace Indexes {
  
!         XiborManager::HistoryMap XiborManager::historyMap_;
  
          void XiborManager::setHistory(const std::string& name,
              const History& history) {
!                 historyMap_[name] = history;
          }
  
          const History& XiborManager::getHistory(const std::string& name) {
              XiborManager::HistoryMap::const_iterator i =
!                 historyMap_.find(name);
!             QL_REQUIRE(i != historyMap_.end(),
                  name + " history not loaded");
              return i->second;
          }
  
          bool XiborManager::hasHistory(const std::string& name) {
!             return (historyMap_.find(name) != historyMap_.end());
          }
  
          std::vector<std::string> XiborManager::histories() {
              std::vector<std::string> temp;
              XiborManager::HistoryMap::const_iterator i;
!             for (i = historyMap_.begin(); i != historyMap_.end(); i++)
                  temp.push_back(i->first);
              return temp;
          }
  
      }
  
  }
--- 30,74 ----
  
      namespace Indexes {
  
!         bool XiborManager::initialized_ = false;
!         XiborManager::HistoryMap* XiborManager::historyMap_ = 0;
  
          void XiborManager::setHistory(const std::string& name,
              const History& history) {
!                 checkHistoryMap();
!                 (*historyMap_)[name] = history;
          }
  
          const History& XiborManager::getHistory(const std::string& name) {
+             checkHistoryMap();
              XiborManager::HistoryMap::const_iterator i =
!                 historyMap_->find(name);
!             QL_REQUIRE(i != historyMap_->end(),
                  name + " history not loaded");
              return i->second;
          }
  
          bool XiborManager::hasHistory(const std::string& name) {
!             checkHistoryMap();
!             return (historyMap_->find(name) != historyMap_->end());
          }
  
          std::vector<std::string> XiborManager::histories() {
+             checkHistoryMap();
              std::vector<std::string> temp;
              XiborManager::HistoryMap::const_iterator i;
!             for (i = historyMap_->begin(); i != historyMap_->end(); i++)
                  temp.push_back(i->first);
              return temp;
          }
  
+         void XiborManager::checkHistoryMap() {
+             if (!initialized_) {
+                 historyMap_ = new HistoryMap;
+                 initialized_ = true;
+             }
+         }
+                 
      }
  
  }
