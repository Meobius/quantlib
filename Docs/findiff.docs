
/*! \page findiff The finite differences framework
    This framework (corresponding to the FiniteDifferences namespace)
    contains basic building blocks for the numerical solution of a generic
    differential equation
    \f[
        \frac{\partial f}{\partial t} = Lf
    \f]
    where \f$ L \f$ is a differential operator in ``space'', i.e., one which
    does not contain partial derivatives in \f$ t \f$ but can otherwise
    contain any derivative in any other variable of the problem.

    Writing the equation in the above form allows us to implement
    separately the discretization of the differential operator \f$ L \f$
    and the time scheme used for the evolution of the solution. The
    FiniteDifferenceModel class acts as a glue for such two steps---which are
    outlined in the following subsections---and provides the interface of the
    resulting finite difference model for the end user. Furthermore, it
    provides the user with the possibility of checking and operating on the
    solution array at each step---which is typically used to apply an
    exercise condition for an option. This is also outlined in a subsection
    below.


    \subsection operators Differential operators
    The discretization of the differential operator \f$ L \f$ depends on the
    discretization chosen for the solution \f$ f \f$ of the given equation.

    Such choice is obvious in the 1-D case where the domain
    \f$ [a,b] \f$ of the equation is discretized as a series of points
    \f$ x_i, i=0 \dots N-1 \f$ (note that the index is zero based) where
    \f$ x_i = a + hi \f$ and \f$ h = (b-a)/(N-1) \f$. In turn, the solution
    \f$ f \f$ of the equation is discretized as an array
    \f$ u_i, i=0 \dots N-1 \f$ whose elements are defined as
    \f$ u_i = f(x_i) \f$.
    The discretization of the differential operator follows by substituting
    the derivatives with the corresponding incremental ratios defined in
    terms of the \f$ f_i \f$. A number of basic operators are defined in the
    framework which can be composed to form more complex operators, namely:

    the identity operator \f$ I \f$ is implemented in class Identity;

    the first derivative \f$ \partial/\partial x \f$ is discretized as the
    operator \f$ D_+ \f$, defined as
    \f[ D_{+} u_{i} = \frac{u_{i+1}-u_{i}}{h} \f]
    and implemented in class DPlus; the operator \f$ D_- \f$, defined as
    \f[ D_{-} u_{i} = \frac{u_{i}-u_{i-1}}{h} \f]
    and implemented in class DMinus; and the operator \f$ D_0 \f$, defined as
    \f[ D_{0} u_{i} = \frac{u_{i+1}-u_{i-1}}{2h} \f]
    and implemented in class DZero.
    The discretization error of the above operators is \f$ O(h) \f$ for
    \f$ D_+ \f$ and \f$ D_- \f$ and \f$ O(h^2) \f$ for \f$ D_0 \f$;

    the second derivative \f$ \partial^2/\partial x^2 \f$ is
    discretized as the operator \f$ D_+D_- \f$, defined as
    \f[ D_{+}D_{-} u_{i} = \frac{u_{i+1}-2u_{i}+u_{i-1}}{h^2} \f]
    and implemented in class DPlusDMinus. Its discretization error is
    \f$ O(h^2) \f$.

    The boundary condition for the above operators is by default linear
    extrapolation. Methods are currently provided for setting other kinds
    of boundary conditions to a TridiagonalOperator which these operators
    inherit, namely, Dirichlet---i.e., constant value---and Neumann---i.e.,
    constant derivative---boundary conditions.
    This might change in the future as boundary conditions could be
    astracted and passed as an additional argument to the model.

    A programmer can also implement its own operator.
    However, in order to fit into this framework it will have to implement
    a required interface depending on the chosen evolver (see below). Also,
    it is currently required to manage itself any boundary conditions. Again,
    this could change in the future.

    On the other hand, there is no obvious choice in the 2-D case.
    While it is immediate to discretize the domain into a series of points
    \f$ (x_i,y_j) \f$ and the solution into a matrix
    \f$ f_{ij} = f(x_i,y_j) \f$, there is a number of ways into which
    the \f$ f_{ij} \f$ can be arranged into an array---each of them
    determining a different discretization of the differential operators.
    One of such ways was implemented in the LexicographicalView class,
    while others will be implemented in the future. No 2-D operator is
    currently implemented apart from the identity operator.


    \subsection evolvers Time schemes
    Once the differential operator \f$ L \f$ has been discretized, a number
    of choices are available for discretizing the time derivative at the
    left-hand side of the equation.

    In this framework, such choice is encapsulated in so-called evolvers
    which, given \f$ L \f$ and the solution \f$ u^{(k)} \f$ at time
    \f$ t_k \f$, yield the solution \f$ u^{(k-1)} \f$ at the previous
    time step.

    A number of evolvers are currently provided in the library which
    implement well-known schemes, namely,

    the forward Euler scheme in which the equation is discretized as
    \f[ \frac{u^{(k)}-u^{(k-1)}}{\Delta t} = Lu^{(k)} \f]
    hence
    \f[ u^{(k-1)} = \left( I - \Delta t L \right) u^{(k)} \f]
    from which \f$ u^{(k-1)} \f$ can be obtained directly;

    the backward Euler scheme in which the equation is discretized as
    \f[ \frac{u^{(k)}-u^{(k-1)}}{\Delta t} = Lu^{(k-1)} \f]
    hence
    \f[ \left( I + \Delta t L \right) u^{(k-1)} = u^{(k)} \f]
    from which \f$ u^{(k-1)} \f$ can be obtained by solving a linear system;

    the Crank-Nicolson scheme in which the equation is discretized as
    \f[ \frac{u^{(k)}-u^{(k-1)}}{\Delta t} =
        L \frac{u^{(k)}+u^{(k-1)}}{2} \f]
    hence
    \f[ \left( I + \frac{\Delta t}{2} L \right) u^{(k-1)} =
        \left( I - \frac{\Delta t}{2} L \right) u^{(k)} \f]
    from which \f$ u^{(k-1)} \f$ can be obtained by solving a linear system.

    Each of the above evolvers forces a set of interface requirements upon
    the differential operator which are detailed in the documentation of the
    corresponding class, namely, ForwardEuler, BackwardEuler, and
    CrankNicolson, respectively.

    A programmer could implement its own evolver, which does not need to
    inherit from any base class.

    However, it must implement the following interface:

    \code
    class Evolver {
      public:
        typedef ... arrayType;
        typedef ... operatorType;
        // constructors
        Evolver(const operatorType& D);
        // member functions
        void step(arrayType& a, Time t) const;
        void setStep(Time dt);
    };
    \endcode

    Finally, we note again that the pricing of an option requires
    the finite difference model to solve the corresponding equation
    <em>backwards</em> in time. Therefore, given a discretization \f$ u \f$
    of the solution at a given time \f$ t \f$, the call
    \code
    evolver.step(u,t)
    \endcode
    must calculate the discrete solution at the <em>previous</em> time,
    \f$ t-dt \f$.


    \subsection conditions Step conditions
    A finite difference model can be passed a step condition to be
    applied at each step during the rollback of the solution (e.g. the early
    exercise American condition). Such condition
    must be embodied in a class derived from StepCondition and must implement
    the interface of the latter, namely,
    \code
    class MyCondition : public StepCondition<arrayType> {
      public:
        void applyTo(arrayType& a, Time t) const;
    };
    \endcode


    \subsection example An example of finite difference model
    The Black-Scholes equation can be written in the above form as
    \f[ \frac{\partial f}{\partial t} =
            - \frac{\sigma^2}{2} \frac{\partial^2 f}{\partial x^2}
            - \nu \frac{\partial f}{\partial x}
            + r f. \f]
    It can be seen that the operator \f$ L_{BS} \f$ is
    \f[ L_{BS} = - \frac{\sigma^2}{2} \frac{\partial^2}{\partial x^2}
                 - \nu \frac{\partial}{\partial x}
                 + r I \f]
    and can be built from the basic operators provided in the library as
    \f[ L_{BS} = - \frac{\sigma^2}{2} D_{+}D_{-}
                 - \nu D_{0} + r I. \f]

    Its implementation closely reflects the above decomposition and
    can be written as
    \code
    class BlackScholesOperator : public TridiagonalOperator {
      public:
        BlackScholesOperator(
            double sigma, double nu,    // parameters of the
            Rate r,                     // Black-Scholes equation;
            unsigned int points,        // number of discretized points;
            double h)                   // grid spacing.
        : TridiagonalOperator(
            // build the operator by adding basic ones
            - (sigma*sigma/2.0) * DPlusDMinus(points,h)
            - nu * DZero(points,h)
            + r * TridiagonalOperator::identity(points)
        ) {}
    };
    \endcode
    taking as inputs the relevant parameters of the equation
    (\f$ \sigma \f$, \f$ \nu \f$ and \f$ r \f$) as well as model parameters
    such as the number \f$ N \f$ of grid points and their spacing \f$ h \f$.

    As simple example cases, we will use the above operator to price both an
    European and an American option. The parameters of the two options will
    be the same, namely, they will be both call options with underlying price
    \f$ u = 100 \f$, strike \f$ s = 95 \f$, residual time \f$ T = 1 \f$ year,
    dividend yield \f$ q = 3\% \f$ and volatility \f$ \sigma = 10\% \f$. The
    risk-free rate will be \f$ r = 5\% \f$. Such parameters are expressed
    using %QuantLib types as
    \code
    Option::Type type = Option::Call;
    double underlying = 100.0, strike = 95.0;
    Time residualTime = 1.0;
    Rate dividendYield = 0.03, riskFreeRate = 0.05;
    double volatility = 0.10;
    \endcode

    The grid upon which the model will act will be a logarithmic grid of
    underlying prices, i.e., \f$ f \f$ will be defined in a range
    \f$ [ \ln u_{min}, \ln u_{max}] \f$ discretized as an array
    \f$ x_i, i = 0 \dots N-1 \f$ with \f$ x_i = \ln u_{min} + ih \f$ and
    \f$ h = (\ln u_{max} - \ln u_{min})/(N-1) \f$.
    Such a grid and the corresponding vector of actual prices can be built
    as shown in the code below. The domain of the model will be defined
    as \f$ [ \ln u - \Delta, \ln u + \Delta ] \f$ where
    \f$ \Delta = 4 \sigma \sqrt{T} \f$. A number of grid points
    \f$ N = 101 \f$ will be used.
    \code
    unsigned int gridPoints = 101;
    Array grid(gridPoints), prices(gridPoints);
    double x0 = QL_LOG(underlying);
    double Delta = 4.0*volatility*QL_SQRT(residualTime);
    double xMin = x0 - Delta, xMax = x0 + Delta;
    double h = (xMax-xMin)/(gridPoints-1);
    for (unsigned int i=0; i<gridPoints; i++) {
        grid[i] = xMin + i*h;
        prices[i] = QL_EXP(grid[i]);
    }
    \endcode

    The initial condition is determined by the values of the option at
    maturity, i.e., either the difference between underlying price and
    strike if such difference is positive, or 0 if that is not the case
    (the above will have to be suitably modified for a put option or
    a straddle.)
    Such ``initial'' condition will be rolled back in time by our model.
    \code
    Array exercisingValue(gridPoints);
    for (unsigned int i=0; i<gridPoints; i++)
        exercisingValue[i] = QL_MAX(prices[i]-strike,0.0);
    \endcode

    Now the differential operator can be initialized. Also, Neumann
    initial conditions are set which correspond to the initial value
    of the derivatives at the boundaries (see the BoundaryCondition
    class documentation for details).
    \code
    double nu = riskFreeRate - dividendYield - volatility*volatility/2.0;
    TridiagonalOperator L = BlackScholesOperator(volatility, nu,
        riskFreeRate, gridPoints, h);
    L.setLowerBC(BoundaryCondition(BoundaryCondition::Neumann,
        exercisingValue[1]-exercisingValue[0]));
    L.setUpperBC(BoundaryCondition(BoundaryCondition::Neumann,
        exercisingValue[gridPoints_-1]-exercisingValue[gridPoints_-2]));
    \endcode

    We are now already set for the pricing of the European option.
    Also, the exercise condition is the only thing still to be defined
    for the American option to be priced. Such condition is equivalent to
    the statement that at each time step, the value of the option is the
    maximum between the profit realized in exercising the option (which we
    already calculated and stored in <tt>exercisingValue</tt>) and the value
    of the option should we keep it (which corresponds to the solution rolled
    back to the current time step). This logic can be implemented as:
    \code
    class ExerciseCondition : public StepCondition<Array> {
      public:
        ExerciseCondition(const Array& exercisingValue)
        : exercisingValue_(exercisingValue) {}
        void applyTo(Array& a, Time) const {
            for (unsigned int i = 0; i < a.size(); i++)
                a[i] = QL_MAX(a[i], exercisingValue_[i]);
        }
      private:
        Array exercisingValue_;
    };
    \endcode

    Everything is now ready. The model can be created gluing the piece
    together by means of the FiniteDifferenceModel class. The current value
    of the option is calculated by rolling back the solution to the current
    time, i.e., \f$ t = 0 \f$, and by taking the value corresponding at the
    current underlying price---which by construction corresponds to the
    central value provided that the number of grid points is odd.
    \code
    unsigned int timeSteps = 365;

    // build the model - Crank-Nicolson scheme chosen
    FiniteDifferenceModel<CrankNicolson<TridiagonalOperator> > model(L);

    // European option
    Array f = exercisingValue;  // initial condition
    model.rollback(f, residualTime, 0.0, timeSteps);
    double europeanValue = valueAtCenter(f);

    // American option
    f = exercisingValue;        // reset
    Handle<StepCondition<Array> > condition(
        new ExerciseCondition(exercisingValue));
    model.rollback(f, residualTime, 0.0, timeSteps, condition);
    double americanValue = valueAtCenter(f);
    \endcode
*/
